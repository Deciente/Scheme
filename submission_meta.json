{
    "assignment": {
        "active": false,
        "autograding_enabled": true,
        "autograding_key": "",
        "course": {
            "active": true,
            "created": "2015-08-24 20:37:42.000000",
            "display_name": "CS 61A",
            "id": 5631829415559168,
            "institution": "UC Berkeley",
            "instructor": [],
            "offering": "cal/cs61a/fa15"
        },
        "created": "2015-11-03 22:18:40.904230",
        "creator": {
            "created": "2015-01-23 09:10:24.000000",
            "email": [
                "sumukh@berkeley.edu"
            ],
            "id": 5644720948641792,
            "is_admin": true
        },
        "display_name": "Scheme",
        "due_date": "2015-11-19 23:59:59.000000",
        "id": 5300076173852672,
        "lock_date": "2015-11-22 23:59:59.000000",
        "max_group_size": 2,
        "name": "cal/cs61a/fa15/proj4",
        "points": 28.0,
        "revision": false,
        "templates": "\"{'scheme.py': '\\\"\\\"\\\"A Scheme interpreter and its read-eval-print loop.\\\"\\\"\\\"\\\\n\\\\nfrom scheme_primitives import *\\\\nfrom scheme_reader import *\\\\nfrom ucb import main, trace\\\\n\\\\n##############\\\\n# Eval/Apply #\\\\n##############\\\\n\\\\ndef scheme_eval(expr, env, _=None): # Optional third argument is ignored\\\\n    \\\"\\\"\\\"Evaluate Scheme expression EXPR in environment ENV.\\\\n\\\\n    >>> expr = read_line(\\\"(+ 2 2)\\\")\\\\n    >>> expr\\\\n    Pair(\\\\'+\\\\', Pair(2, Pair(2, nil)))\\\\n    >>> scheme_eval(expr, create_global_frame())\\\\n    4\\\\n    \\\"\\\"\\\"\\\\n    # Atoms\\\\n    assert expr is not None\\\\n    if scheme_symbolp(expr):\\\\n        return env.lookup(expr)\\\\n    elif self_evaluating(expr):\\\\n        return expr\\\\n\\\\n    # Combinations\\\\n    if not scheme_listp(expr):\\\\n        raise SchemeError(\\\"malformed list: {0}\\\".format(str(expr)))\\\\n    first, rest = expr.first, expr.second\\\\n    if scheme_symbolp(first) and first in SPECIAL_FORMS:\\\\n        result = SPECIAL_FORMS[first](rest, env)\\\\n    else:\\\\n        procedure = scheme_eval(first, env)\\\\n        args = rest.map(lambda operand: scheme_eval(operand, env))\\\\n        result = scheme_apply(procedure, args, env)\\\\n    return result\\\\n\\\\ndef self_evaluating(expr):\\\\n    \\\"\\\"\\\"Return whether EXPR evaluates to itself.\\\"\\\"\\\"\\\\n    return scheme_atomp(expr) or scheme_stringp(expr) or expr is okay\\\\n\\\\n\\\\ndef scheme_apply(procedure, args, env):\\\\n    \\\"\\\"\\\"Apply Scheme PROCEDURE to argument values ARGS in environment ENV.\\\"\\\"\\\"\\\\n    if isinstance(procedure, PrimitiveProcedure):\\\\n        return apply_primitive(procedure, args, env)\\\\n    elif isinstance(procedure, UserDefinedProcedure):\\\\n        new_env = make_call_frame(procedure, args, env)\\\\n        return eval_all(procedure.body, new_env)\\\\n    else:\\\\n        raise SchemeError(\\\"cannot call: {0}\\\".format(str(procedure)))\\\\n\\\\ndef apply_primitive(procedure, args_scheme_list, env):\\\\n    \\\"\\\"\\\"Apply PrimitiveProcedure PROCEDURE to ARGS_SCHEME_LIST in ENV.\\\\n\\\\n    >>> env = create_global_frame()\\\\n    >>> plus = env.bindings[\\\"+\\\"]\\\\n    >>> twos = Pair(2, Pair(2, nil))\\\\n    >>> apply_primitive(plus, twos, env)\\\\n    4\\\\n    \\\"\\\"\\\"\\\\n    # Convert a Scheme list to a Python list\\\\n    args = []\\\\n    while args_scheme_list is not nil:\\\\n        args.append(args_scheme_list.first)\\\\n        args_scheme_list = args_scheme_list.second\\\\n    # BEGIN Question 4\\\\n    \\\"*** REPLACE THIS LINE ***\\\"\\\\n    # END Question 4\\\\n\\\\ndef eval_all(expressions, env):\\\\n    \\\"\\\"\\\"Evaluate a Scheme list of EXPRESSIONS & return the value of the last.\\\"\\\"\\\"\\\\n    # BEGIN Question 7\\\\n    \\\"*** REPLACE THIS LINE ***\\\"\\\\n    return scheme_eval(expressions.first, env)\\\\n    # END Question 7\\\\n\\\\ndef make_call_frame(procedure, args, env):\\\\n    \\\"\\\"\\\"Make a frame that binds the formal parameters of PROCEDURE to ARGS.\\\"\\\"\\\"\\\\n    # BEGIN Question 12\\\\n    \\\"*** REPLACE THIS LINE ***\\\"\\\\n    # END Question 12\\\\n\\\\n################\\\\n# Environments #\\\\n################\\\\n\\\\nclass Frame:\\\\n    \\\"\\\"\\\"An environment frame binds Scheme symbols to Scheme values.\\\"\\\"\\\"\\\\n\\\\n    def __init__(self, parent):\\\\n        \\\"\\\"\\\"An empty frame with a PARENT frame (which may be None).\\\"\\\"\\\"\\\\n        self.bindings = {}\\\\n        self.parent = parent\\\\n\\\\n    def __repr__(self):\\\\n        if self.parent is None:\\\\n            return \\\"<Global Frame>\\\"\\\\n        else:\\\\n            s = sorted(\\\\'{0}: {1}\\\\'.format(k,v) for k,v in self.bindings.items())\\\\n            return \\\"<{{{0}}} -> {1}>\\\".format(\\\\', \\\\'.join(s), repr(self.parent))\\\\n\\\\n    def lookup(self, symbol):\\\\n        \\\"\\\"\\\"Return the value bound to SYMBOL.  Errors if SYMBOL is not found.\\\"\\\"\\\"\\\\n        # BEGIN Question 3\\\\n        \\\"*** REPLACE THIS LINE ***\\\"\\\\n        # END Question 3\\\\n        raise SchemeError(\\\"unknown identifier: {0}\\\".format(symbol))\\\\n\\\\n    def make_child_frame(self, formals, vals):\\\\n        \\\"\\\"\\\"Return a new local frame whose parent is SELF, in which the symbols\\\\n        in a Scheme list of formal parameters FORMALS are bound to the Scheme\\\\n        values in the Scheme list VALS. Raise an error if too many or too few\\\\n        vals are given.\\\\n\\\\n        >>> env = create_global_frame()\\\\n        >>> formals, expressions = read_line(\\\"(a b c)\\\"), read_line(\\\"(1 2 3)\\\")\\\\n        >>> env.make_child_frame(formals, expressions)\\\\n        <{a: 1, b: 2, c: 3} -> <Global Frame>>\\\\n        \\\"\\\"\\\"\\\\n        child = Frame(self) # Create a new child with self as the parent\\\\n        # BEGIN Question 10\\\\n        \\\"*** REPLACE THIS LINE ***\\\"\\\\n        # END Question 10\\\\n        return child\\\\n\\\\n    def define(self, symbol, value):\\\\n        \\\"\\\"\\\"Define Scheme SYMBOL to have VALUE.\\\"\\\"\\\"\\\\n        self.bindings[symbol] = value\\\\n\\\\nclass UserDefinedProcedure:\\\\n    \\\"\\\"\\\"A procedure defined by an expression.\\\"\\\"\\\"\\\\n\\\\nclass LambdaProcedure(UserDefinedProcedure):\\\\n    \\\"\\\"\\\"A procedure defined by a lambda expression or a define form.\\\"\\\"\\\"\\\\n\\\\n    def __init__(self, formals, body, env):\\\\n        \\\"\\\"\\\"A procedure with formal parameter list FORMALS (a Scheme list),\\\\n        a Scheme list of BODY expressions, and a parent environment that\\\\n        starts with Frame ENV.\\\\n        \\\"\\\"\\\"\\\\n        self.formals = formals\\\\n        self.body = body\\\\n        self.env = env\\\\n\\\\n    def __str__(self):\\\\n        return str(Pair(\\\"lambda\\\", Pair(self.formals, self.body)))\\\\n\\\\n    def __repr__(self):\\\\n        return \\\"LambdaProcedure({!r}, {!r}, {!r})\\\".format(\\\\n            self.formals, self.body, self.env)\\\\n\\\\n#################\\\\n# Special forms #\\\\n#################\\\\n\\\\ndef do_define_form(expressions, env):\\\\n    \\\"\\\"\\\"Evaluate a define form.\\\"\\\"\\\"\\\\n    check_form(expressions, 2)\\\\n    target = expressions.first\\\\n    if scheme_symbolp(target):\\\\n        check_form(expressions, 2, 2)\\\\n        # BEGIN Question 5A\\\\n        \\\"*** REPLACE THIS LINE ***\\\"\\\\n        # END Question 5A\\\\n    elif isinstance(target, Pair) and scheme_symbolp(target.first):\\\\n        # BEGIN Question 9A\\\\n        \\\"*** REPLACE THIS LINE ***\\\"\\\\n        # END Question 9A\\\\n    else:\\\\n        bad = target.first if isinstance(target, Pair) else target\\\\n        raise SchemeError(\\\"Non-symbol: {}\\\".format(bad))\\\\n\\\\ndef do_quote_form(expressions, env):\\\\n    \\\"\\\"\\\"Evaluate a quote form.\\\"\\\"\\\"\\\\n    check_form(expressions, 1, 1)\\\\n    # BEGIN Question 6B\\\\n    \\\"*** REPLACE THIS LINE ***\\\"\\\\n    # END Question 6B\\\\n\\\\ndef do_begin_form(expressions, env):\\\\n    \\\"\\\"\\\"Evaluate begin form.\\\"\\\"\\\"\\\\n    check_form(expressions, 1)\\\\n    return eval_all(expressions, env)\\\\n\\\\ndef do_lambda_form(expressions, env):\\\\n    \\\"\\\"\\\"Evaluate a lambda form.\\\"\\\"\\\"\\\\n    check_form(expressions, 2)\\\\n    formals = expressions.first\\\\n    check_formals(formals)\\\\n    # BEGIN Question 8\\\\n    \\\"*** REPLACE THIS LINE ***\\\"\\\\n    # END Question 8\\\\n\\\\ndef do_if_form(expressions, env):\\\\n    \\\"\\\"\\\"Evaluate an if form.\\\"\\\"\\\"\\\\n    check_form(expressions, 2, 3)\\\\n    # BEGIN Question 13\\\\n    \\\"*** REPLACE THIS LINE ***\\\"\\\\n    # END Question 13\\\\n\\\\ndef do_and_form(expressions, env):\\\\n    \\\"\\\"\\\"Evaluate a short-circuited and form.\\\"\\\"\\\"\\\\n    # BEGIN Question 14B\\\\n    \\\"*** REPLACE THIS LINE ***\\\"\\\\n    # END Question 14B\\\\n\\\\ndef do_or_form(expressions, env):\\\\n    \\\"\\\"\\\"Evaluate a short-circuited or form.\\\"\\\"\\\"\\\\n    # BEGIN Question 14B\\\\n    \\\"*** REPLACE THIS LINE ***\\\"\\\\n    # END Question 14B\\\\n\\\\ndef do_cond_form(expressions, env):\\\\n    \\\"\\\"\\\"Evaluate a cond form.\\\"\\\"\\\"\\\\n    num_clauses = len(expressions)\\\\n    i = 0\\\\n    while expressions is not nil:\\\\n        clause = expressions.first\\\\n        check_form(clause, 1)\\\\n        if clause.first == \\\"else\\\":\\\\n            if i < num_clauses-1:\\\\n                raise SchemeError(\\\"else must be last\\\")\\\\n            test = True\\\\n        else:\\\\n            test = scheme_eval(clause.first, env)\\\\n        if scheme_true(test):\\\\n            # BEGIN Question 15A\\\\n            \\\"*** REPLACE THIS LINE ***\\\"\\\\n            # END Question 15A\\\\n        expressions = expressions.second\\\\n        i += 1\\\\n    return okay\\\\n\\\\ndef do_let_form(expressions, env):\\\\n    \\\"\\\"\\\"Evaluate a let form.\\\"\\\"\\\"\\\\n    check_form(expressions, 2)\\\\n    let_env = make_let_frame(expressions.first, env)\\\\n    return eval_all(expressions.second, let_env)\\\\n\\\\ndef make_let_frame(bindings, env):\\\\n    \\\"\\\"\\\"Create a frame containing bindings from a let expression.\\\"\\\"\\\"\\\\n    if not scheme_listp(bindings):\\\\n        raise SchemeError(\\\"bad bindings list in let form\\\")\\\\n    # BEGIN Question 16\\\\n    \\\"*** REPLACE THIS LINE ***\\\"\\\\n    # END Question 16\\\\n\\\\nSPECIAL_FORMS = {\\\\n    \\\"and\\\": do_and_form,\\\\n    \\\"begin\\\": do_begin_form,\\\\n    \\\"cond\\\": do_cond_form,\\\\n    \\\"define\\\": do_define_form,\\\\n    \\\"if\\\": do_if_form,\\\\n    \\\"lambda\\\": do_lambda_form,\\\\n    \\\"let\\\": do_let_form,\\\\n    \\\"or\\\": do_or_form,\\\\n    \\\"quote\\\": do_quote_form,\\\\n}\\\\n\\\\n# Utility methods for checking the structure of Scheme programs\\\\n\\\\ndef check_form(expr, min, max=float(\\\\'inf\\\\')):\\\\n    \\\"\\\"\\\"Check EXPR is a proper list whose length is at least MIN and no more\\\\n    than MAX (default: no maximum). Raises a SchemeError if this is not the\\\\n    case.\\\\n    \\\"\\\"\\\"\\\\n    if not scheme_listp(expr):\\\\n        raise SchemeError(\\\"badly formed expression: \\\" + str(expr))\\\\n    length = len(expr)\\\\n    if length < min:\\\\n        raise SchemeError(\\\"too few operands in form\\\")\\\\n    elif length > max:\\\\n        raise SchemeError(\\\"too many operands in form\\\")\\\\n\\\\ndef check_formals(formals):\\\\n    \\\"\\\"\\\"Check that FORMALS is a valid parameter list, a Scheme list of symbols\\\\n    in which each symbol is distinct. Raise a SchemeError if the list of\\\\n    formals is not a well-formed list of symbols or if any symbol is repeated.\\\\n\\\\n    >>> check_formals(read_line(\\\"(a b c)\\\"))\\\\n    \\\"\\\"\\\"\\\\n    # BEGIN Question 11B\\\\n    \\\"*** REPLACE THIS LINE ***\\\"\\\\n    # END Question 11B\\\\n\\\\n#################\\\\n# Dynamic Scope #\\\\n#################\\\\n\\\\nclass MuProcedure(UserDefinedProcedure):\\\\n    \\\"\\\"\\\"A procedure defined by a mu expression, which has dynamic scope.\\\\n     _________________\\\\n    < Scheme is cool! >\\\\n     -----------------\\\\n            \\\\\\\\   ^__^\\\\n             \\\\\\\\  (oo)\\\\\\\\_______\\\\n                (__)\\\\\\\\       )\\\\\\\\/\\\\\\\\\\\\n                    ||----w |\\\\n                    ||     ||\\\\n    \\\"\\\"\\\"\\\\n\\\\n    def __init__(self, formals, body):\\\\n        \\\"\\\"\\\"A procedure with formal parameter list FORMALS (a Scheme list) and a\\\\n        Scheme list of BODY expressions.\\\\n        \\\"\\\"\\\"\\\\n        self.formals = formals\\\\n        self.body = body\\\\n\\\\n    def __str__(self):\\\\n        return str(Pair(\\\"mu\\\", Pair(self.formals, self.body)))\\\\n\\\\n    def __repr__(self):\\\\n        return \\\"MuProcedure({!r}, {!r})\\\".format(self.formals, self.body)\\\\n\\\\n\\\\ndef do_mu_form(expressions, env):\\\\n    \\\"\\\"\\\"Evaluate a mu form.\\\"\\\"\\\"\\\\n    check_form(expressions, 2)\\\\n    formals = expressions.first\\\\n    check_formals(formals)\\\\n    # BEGIN Question 17\\\\n    \\\"*** REPLACE THIS LINE ***\\\"\\\\n    # END Question 17\\\\n\\\\nSPECIAL_FORMS[\\\"mu\\\"] = do_mu_form\\\\n\\\\n\\\\n##################\\\\n# Tail Recursion #\\\\n##################\\\\n\\\\nclass Evaluate:\\\\n    \\\"\\\"\\\"An expression EXPR to be evaluated in environment ENV.\\\"\\\"\\\"\\\\n    def __init__(self, expr, env):\\\\n        self.expr = expr\\\\n        self.env = env\\\\n\\\\ndef scheme_optimized_eval(expr, env, tail=False):\\\\n    \\\"\\\"\\\"Evaluate Scheme expression EXPR in environment ENV.\\\"\\\"\\\"\\\\n    # Evaluate Atoms\\\\n    assert expr is not None\\\\n    if scheme_symbolp(expr):\\\\n        return env.lookup(expr)\\\\n    elif self_evaluating(expr):\\\\n        return expr\\\\n\\\\n    if tail:\\\\n        # BEGIN Extra Credit\\\\n        \\\"*** REPLACE THIS LINE ***\\\"\\\\n        # END Extra Credit\\\\n    else:\\\\n        result = Evaluate(expr, env)\\\\n\\\\n    while isinstance(result, Evaluate):\\\\n        expr, env = result.expr, result.env\\\\n        # All non-atomic expressions are lists (combinations)\\\\n        if not scheme_listp(expr):\\\\n            raise SchemeError(\\\"malformed list: {0}\\\".format(str(expr)))\\\\n        first, rest = expr.first, expr.second\\\\n        if (scheme_symbolp(first) and first in SPECIAL_FORMS):\\\\n            result = SPECIAL_FORMS[first](rest, env)\\\\n        else:\\\\n            procedure = scheme_eval(first, env)\\\\n            args = rest.map(lambda operand: scheme_eval(operand, env))\\\\n            result = scheme_apply(procedure, args, env)\\\\n    return result\\\\n\\\\n################################################################\\\\n# Uncomment the following line to apply tail call optimization #\\\\n################################################################\\\\n# scheme_eval = scheme_optimized_eval\\\\n\\\\n\\\\n################\\\\n# Input/Output #\\\\n################\\\\n\\\\ndef read_eval_print_loop(next_line, env, interactive=False, quiet=False,\\\\n                         startup=False, load_files=()):\\\\n    \\\"\\\"\\\"Read and evaluate input until an end of file or keyboard interrupt.\\\"\\\"\\\"\\\\n    if startup:\\\\n        for filename in load_files:\\\\n            scheme_load(filename, True, env)\\\\n    while True:\\\\n        try:\\\\n            src = next_line()\\\\n            while src.more_on_line:\\\\n                expression = scheme_read(src)\\\\n                result = scheme_eval(expression, env)\\\\n                if not quiet and result is not None:\\\\n                    print(result)\\\\n        except (SchemeError, SyntaxError, ValueError, RuntimeError) as err:\\\\n            if (isinstance(err, RuntimeError) and\\\\n                \\\\'maximum recursion depth exceeded\\\\' not in getattr(err, \\\\'args\\\\')[0]):\\\\n                raise\\\\n            elif isinstance(err, RuntimeError):\\\\n                print(\\\"Error: maximum recursion depth exceeded\\\")\\\\n            else:\\\\n                print(\\\"Error:\\\", err)\\\\n        except KeyboardInterrupt:  # <Control>-C\\\\n            if not startup:\\\\n                raise\\\\n            print()\\\\n            print(\\\"KeyboardInterrupt\\\")\\\\n            if not interactive:\\\\n                return\\\\n        except EOFError:  # <Control>-D, etc.\\\\n            print()\\\\n            return\\\\n\\\\ndef scheme_load(*args):\\\\n    \\\"\\\"\\\"Load a Scheme source file. ARGS should be of the form (SYM, ENV) or (SYM,\\\\n    QUIET, ENV). The file named SYM is loaded in environment ENV, with verbosity\\\\n    determined by QUIET (default true).\\\"\\\"\\\"\\\\n    if not (2 <= len(args) <= 3):\\\\n        expressions = args[:-1]\\\\n        raise SchemeError(\\\\'\\\"load\\\" given incorrect number of arguments: \\\\'\\\\n                          \\\\'{0}\\\\'.format(len(expressions)))\\\\n    sym = args[0]\\\\n    quiet = args[1] if len(args) > 2 else True\\\\n    env = args[-1]\\\\n    if (scheme_stringp(sym)):\\\\n        sym = eval(sym)\\\\n    check_type(sym, scheme_symbolp, 0, \\\"load\\\")\\\\n    with scheme_open(sym) as infile:\\\\n        lines = infile.readlines()\\\\n    args = (lines, None) if quiet else (lines,)\\\\n    def next_line():\\\\n        return buffer_lines(*args)\\\\n\\\\n    read_eval_print_loop(next_line, env, quiet=quiet)\\\\n    return okay\\\\n\\\\ndef scheme_open(filename):\\\\n    \\\"\\\"\\\"If either FILENAME or FILENAME.scm is the name of a valid file,\\\\n    return a Python file opened to it. Otherwise, raise an error.\\\"\\\"\\\"\\\\n    try:\\\\n        return open(filename)\\\\n    except IOError as exc:\\\\n        if filename.endswith(\\\\'.scm\\\\'):\\\\n            raise SchemeError(str(exc))\\\\n    try:\\\\n        return open(filename + \\\\'.scm\\\\')\\\\n    except IOError as exc:\\\\n        raise SchemeError(str(exc))\\\\n\\\\ndef create_global_frame():\\\\n    \\\"\\\"\\\"Initialize and return a single-frame environment with built-in names.\\\"\\\"\\\"\\\\n    env = Frame(None)\\\\n    env.define(\\\"eval\\\", PrimitiveProcedure(scheme_eval, True))\\\\n    env.define(\\\"apply\\\", PrimitiveProcedure(scheme_apply, True))\\\\n    env.define(\\\"load\\\", PrimitiveProcedure(scheme_load, True))\\\\n    add_primitives(env)\\\\n    return env\\\\n\\\\n@main\\\\ndef run(*argv):\\\\n    import argparse\\\\n    parser = argparse.ArgumentParser(description=\\\\'CS 61A Scheme interpreter\\\\')\\\\n    parser.add_argument(\\\\'-load\\\\', \\\\'-i\\\\', action=\\\\'store_true\\\\',\\\\n                       help=\\\\'run file interactively\\\\')\\\\n    parser.add_argument(\\\\'file\\\\', nargs=\\\\'?\\\\',\\\\n                        type=argparse.FileType(\\\\'r\\\\'), default=None,\\\\n                        help=\\\\'Scheme file to run\\\\')\\\\n    args = parser.parse_args()\\\\n\\\\n    next_line = buffer_input\\\\n    interactive = True\\\\n    load_files = []\\\\n\\\\n    if args.file is not None:\\\\n        if args.load:\\\\n            load_files.append(getattr(args.file, \\\\'name\\\\'))\\\\n        else:\\\\n            lines = args.file.readlines()\\\\n            def next_line():\\\\n                return buffer_lines(lines)\\\\n            interactive = False\\\\n\\\\n    read_eval_print_loop(next_line, create_global_frame(), startup=True,\\\\n                         interactive=interactive, load_files=load_files)\\\\n    tscheme_exitonclick()\\\\n', 'tests.scm': ';;; Test cases for Scheme.\\\\n;;;\\\\n;;; In order to run only a prefix of these examples, add the line\\\\n;;;\\\\n;;; (exit)\\\\n;;;\\\\n;;; after the last test you wish to run.\\\\n\\\\n;;; **********************************\\\\n;;; *** Add more of your own here! ***\\\\n;;; **********************************\\\\n\\\\n;;; These are examples from several sections of \\\"The Structure\\\\n;;; and Interpretation of Computer Programs\\\" by Abelson and Sussman.\\\\n\\\\n;;; License: Creative Commons share alike with attribution\\\\n\\\\n;;; 1.1.1\\\\n\\\\n10\\\\n; expect 10\\\\n\\\\n(+ 137 349)\\\\n; expect 486\\\\n\\\\n(- 1000 334)\\\\n; expect 666\\\\n\\\\n(* 5 99)\\\\n; expect 495\\\\n\\\\n(/ 10 5)\\\\n; expect 2\\\\n\\\\n(+ 2.7 10)\\\\n; expect 12.7\\\\n\\\\n(+ 21 35 12 7)\\\\n; expect 75\\\\n\\\\n(* 25 4 12)\\\\n; expect 1200\\\\n\\\\n(+ (* 3 5) (- 10 6))\\\\n; expect 19\\\\n\\\\n(+ (* 3 (+ (* 2 4) (+ 3 5))) (+ (- 10 7) 6))\\\\n; expect 57\\\\n\\\\n(+ (* 3\\\\n      (+ (* 2 4)\\\\n         (+ 3 5)))\\\\n   (+ (- 10 7)\\\\n      6))\\\\n; expect 57\\\\n\\\\n\\\\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\\\\n;;; Move the following (exit) line to run additional tests. ;;;\\\\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\\\\n(exit)\\\\n\\\\n\\\\n;;; 1.1.2\\\\n\\\\n(define size 2)\\\\n; expect size\\\\nsize\\\\n; expect 2\\\\n\\\\n(* 5 size)\\\\n; expect 10\\\\n\\\\n(define pi 3.14159)\\\\n(define radius 10)\\\\n(* pi (* radius radius))\\\\n; expect 314.159\\\\n\\\\n(define circumference (* 2 pi radius))\\\\ncircumference\\\\n; expect 62.8318\\\\n\\\\n;;; 1.1.4\\\\n\\\\n(define (square x) (* x x))\\\\n; expect square\\\\n(square 21)\\\\n; expect 441\\\\n\\\\n(define square (lambda (x) (* x x))) ; See Section 1.3.2\\\\n(square 21)\\\\n; expect 441\\\\n\\\\n(square (+ 2 5))\\\\n; expect 49\\\\n\\\\n(square (square 3))\\\\n; expect 81\\\\n\\\\n(define (sum-of-squares x y)\\\\n  (+ (square x) (square y)))\\\\n(sum-of-squares 3 4)\\\\n; expect 25\\\\n\\\\n(define (f a)\\\\n  (sum-of-squares (+ a 1) (* a 2)))\\\\n(f 5)\\\\n; expect 136\\\\n\\\\n;;; 1.1.6\\\\n\\\\n(define (abs x)\\\\n  (cond ((> x 0) x)\\\\n        ((= x 0) 0)\\\\n        ((< x 0) (- x))))\\\\n(abs -3)\\\\n; expect 3\\\\n\\\\n(abs 0)\\\\n; expect 0\\\\n\\\\n(abs 3)\\\\n; expect 3\\\\n\\\\n(define (a-plus-abs-b a b)\\\\n  ((if (> b 0) + -) a b))\\\\n(a-plus-abs-b 3 -2)\\\\n; expect 5\\\\n\\\\n;;; 1.1.7\\\\n\\\\n(define (sqrt-iter guess x)\\\\n  (if (good-enough? guess x)\\\\n      guess\\\\n      (sqrt-iter (improve guess x)\\\\n                 x)))\\\\n(define (improve guess x)\\\\n  (average guess (/ x guess)))\\\\n(define (average x y)\\\\n  (/ (+ x y) 2))\\\\n(define (good-enough? guess x)\\\\n  (< (abs (- (square guess) x)) 0.001))\\\\n(define (sqrt x)\\\\n  (sqrt-iter 1.0 x))\\\\n(sqrt 9)\\\\n; expect 3.00009155413138\\\\n\\\\n(sqrt (+ 100 37))\\\\n; expect 11.704699917758145\\\\n\\\\n(sqrt (+ (sqrt 2) (sqrt 3)))\\\\n; expect 1.7739279023207892\\\\n\\\\n(square (sqrt 1000))\\\\n; expect 1000.000369924366\\\\n\\\\n;;; 1.1.8\\\\n\\\\n(define (sqrt x)\\\\n  (define (good-enough? guess)\\\\n    (< (abs (- (square guess) x)) 0.001))\\\\n  (define (improve guess)\\\\n    (average guess (/ x guess)))\\\\n  (define (sqrt-iter guess)\\\\n    (if (good-enough? guess)\\\\n        guess\\\\n        (sqrt-iter (improve guess))))\\\\n  (sqrt-iter 1.0))\\\\n(sqrt 9)\\\\n; expect 3.00009155413138\\\\n\\\\n(sqrt (+ 100 37))\\\\n; expect 11.704699917758145\\\\n\\\\n(sqrt (+ (sqrt 2) (sqrt 3)))\\\\n; expect 1.7739279023207892\\\\n\\\\n(square (sqrt 1000))\\\\n; expect 1000.000369924366\\\\n\\\\n;;; 1.3.1\\\\n\\\\n(define (cube x) (* x x x))\\\\n(define (sum term a next b)\\\\n  (if (> a b)\\\\n      0\\\\n      (+ (term a)\\\\n         (sum term (next a) next b))))\\\\n(define (inc n) (+ n 1))\\\\n(define (sum-cubes a b)\\\\n  (sum cube a inc b))\\\\n(sum-cubes 1 10)\\\\n; expect 3025\\\\n\\\\n(define (identity x) x)\\\\n(define (sum-integers a b)\\\\n  (sum identity a inc b))\\\\n(sum-integers 1 10)\\\\n; expect 55\\\\n\\\\n;;; 1.3.2\\\\n\\\\n((lambda (x y z) (+ x y (square z))) 1 2 3)\\\\n; expect 12\\\\n\\\\n(define (f x y)\\\\n  (let ((a (+ 1 (* x y)))\\\\n        (b (- 1 y)))\\\\n    (+ (* x (square a))\\\\n       (* y b)\\\\n       (* a b))))\\\\n(f 3 4)\\\\n; expect 456\\\\n\\\\n(define x 5)\\\\n(+ (let ((x 3))\\\\n     (+ x (* x 10)))\\\\n   x)\\\\n; expect 38\\\\n\\\\n(let ((x 3)\\\\n      (y (+ x 2)))\\\\n  (* x y))\\\\n; expect 21\\\\n\\\\n;;; 2.1.1\\\\n\\\\n(define (add-rat x y)\\\\n  (make-rat (+ (* (numer x) (denom y))\\\\n               (* (numer y) (denom x)))\\\\n            (* (denom x) (denom y))))\\\\n(define (sub-rat x y)\\\\n  (make-rat (- (* (numer x) (denom y))\\\\n               (* (numer y) (denom x)))\\\\n            (* (denom x) (denom y))))\\\\n(define (mul-rat x y)\\\\n  (make-rat (* (numer x) (numer y))\\\\n            (* (denom x) (denom y))))\\\\n(define (div-rat x y)\\\\n  (make-rat (* (numer x) (denom y))\\\\n            (* (denom x) (numer y))))\\\\n(define (equal-rat? x y)\\\\n  (= (* (numer x) (denom y))\\\\n     (* (numer y) (denom x))))\\\\n\\\\n(define x (cons 1 2))\\\\n(car x)\\\\n; expect 1\\\\n\\\\n(cdr x)\\\\n; expect 2\\\\n\\\\n(define x (cons 1 2))\\\\n(define y (cons 3 4))\\\\n(define z (cons x y))\\\\n(car (car z))\\\\n; expect 1\\\\n\\\\n(car (cdr z))\\\\n; expect 3\\\\n\\\\nz\\\\n; expect ((1 . 2) 3 . 4)\\\\n\\\\n(define (make-rat n d) (cons n d))\\\\n(define (numer x) (car x))\\\\n(define (denom x) (cdr x))\\\\n(define (print-rat x)\\\\n  (display (numer x))\\\\n  (display \\\\'/)\\\\n  (display (denom x))\\\\n  (newline))\\\\n(define one-half (make-rat 1 2))\\\\n(print-rat one-half)\\\\n; expect 1/2 ; okay\\\\n\\\\n(define one-third (make-rat 1 3))\\\\n(print-rat (add-rat one-half one-third))\\\\n; expect 5/6 ; okay\\\\n\\\\n(print-rat (mul-rat one-half one-third))\\\\n; expect 1/6 ; okay\\\\n\\\\n(print-rat (add-rat one-third one-third))\\\\n; expect 6/9 ; okay\\\\n\\\\n(define (gcd a b)\\\\n  (if (= b 0)\\\\n      a\\\\n      (gcd b (remainder a b))))\\\\n(define (make-rat n d)\\\\n  (let ((g (gcd n d)))\\\\n    (cons (/ n g) (/ d g))))\\\\n(print-rat (add-rat one-third one-third))\\\\n; expect 2/3 ; okay\\\\n\\\\n(define one-through-four (list 1 2 3 4))\\\\none-through-four\\\\n; expect (1 2 3 4)\\\\n\\\\n(car one-through-four)\\\\n; expect 1\\\\n\\\\n(cdr one-through-four)\\\\n; expect (2 3 4)\\\\n\\\\n(car (cdr one-through-four))\\\\n; expect 2\\\\n\\\\n(cons 10 one-through-four)\\\\n; expect (10 1 2 3 4)\\\\n\\\\n(cons 5 one-through-four)\\\\n; expect (5 1 2 3 4)\\\\n\\\\n(define (map proc items)\\\\n  (if (null? items)\\\\n      nil\\\\n      (cons (proc (car items))\\\\n            (map proc (cdr items)))))\\\\n(map abs (list -10 2.5 -11.6 17))\\\\n; expect (10 2.5 11.6 17)\\\\n\\\\n(map (lambda (x) (* x x))\\\\n     (list 1 2 3 4))\\\\n; expect (1 4 9 16)\\\\n\\\\n(define (scale-list items factor)\\\\n  (map (lambda (x) (* x factor))\\\\n       items))\\\\n(scale-list (list 1 2 3 4 5) 10)\\\\n; expect (10 20 30 40 50)\\\\n\\\\n(define (count-leaves x)\\\\n  (cond ((null? x) 0)\\\\n        ((not (pair? x)) 1)\\\\n        (else (+ (count-leaves (car x))\\\\n                 (count-leaves (cdr x))))))\\\\n(define x (cons (list 1 2) (list 3 4)))\\\\n(count-leaves x)\\\\n; expect 4\\\\n\\\\n(count-leaves (list x x))\\\\n; expect 8\\\\n\\\\n;;; 2.2.3\\\\n\\\\n(define (odd? x) (= 1 (remainder x 2)))\\\\n(define (filter predicate sequence)\\\\n  (cond ((null? sequence) nil)\\\\n        ((predicate (car sequence))\\\\n         (cons (car sequence)\\\\n               (filter predicate (cdr sequence))))\\\\n        (else (filter predicate (cdr sequence)))))\\\\n(filter odd? (list 1 2 3 4 5))\\\\n; expect (1 3 5)\\\\n\\\\n(define (accumulate op initial sequence)\\\\n  (if (null? sequence)\\\\n      initial\\\\n      (op (car sequence)\\\\n          (accumulate op initial (cdr sequence)))))\\\\n(accumulate + 0 (list 1 2 3 4 5))\\\\n; expect 15\\\\n\\\\n(accumulate * 1 (list 1 2 3 4 5))\\\\n; expect 120\\\\n\\\\n(accumulate cons nil (list 1 2 3 4 5))\\\\n; expect (1 2 3 4 5)\\\\n\\\\n(define (enumerate-interval low high)\\\\n  (if (> low high)\\\\n      nil\\\\n      (cons low (enumerate-interval (+ low 1) high))))\\\\n(enumerate-interval 2 7)\\\\n; expect (2 3 4 5 6 7)\\\\n\\\\n(define (enumerate-tree tree)\\\\n  (cond ((null? tree) nil)\\\\n        ((not (pair? tree)) (list tree))\\\\n        (else (append (enumerate-tree (car tree))\\\\n                      (enumerate-tree (cdr tree))))))\\\\n(enumerate-tree (list 1 (list 2 (list 3 4)) 5))\\\\n; expect (1 2 3 4 5)\\\\n\\\\n;;; 2.3.1\\\\n\\\\n(define a 1)\\\\n\\\\n(define b 2)\\\\n\\\\n(list a b)\\\\n; expect (1 2)\\\\n\\\\n(list \\\\'a \\\\'b)\\\\n; expect (a b)\\\\n\\\\n(list \\\\'a b)\\\\n; expect (a 2)\\\\n\\\\n(car \\\\'(a b c))\\\\n; expect a\\\\n\\\\n(cdr \\\\'(a b c))\\\\n; expect (b c)\\\\n\\\\n(define (memq item x)\\\\n  (cond ((null? x) false)\\\\n        ((eq? item (car x)) x)\\\\n        (else (memq item (cdr x)))))\\\\n(memq \\\\'apple \\\\'(pear banana prune))\\\\n; expect False\\\\n\\\\n(memq \\\\'apple \\\\'(x (apple sauce) y apple pear))\\\\n; expect (apple pear)\\\\n\\\\n(define (equal? x y)\\\\n  (cond ((pair? x) (and (pair? y)\\\\n                        (equal? (car x) (car y))\\\\n                        (equal? (cdr x) (cdr y))))\\\\n        ((null? x) (null? y))\\\\n        (else (eq? x y))))\\\\n(equal? \\\\'(1 2 (three)) \\\\'(1 2 (three)))\\\\n; expect True\\\\n\\\\n(equal? \\\\'(1 2 (three)) \\\\'(1 2 three))\\\\n; expect False\\\\n\\\\n(equal? \\\\'(1 2 three) \\\\'(1 2 (three)))\\\\n; expect False\\\\n\\\\n;;; Peter Norvig tests (http://norvig.com/lispy2.html)\\\\n\\\\n(define double (lambda (x) (* 2 x)))\\\\n(double 5)\\\\n; expect 10\\\\n\\\\n(define compose (lambda (f g) (lambda (x) (f (g x)))))\\\\n((compose list double) 5)\\\\n; expect (10)\\\\n\\\\n(define apply-twice (lambda (f) (compose f f)))\\\\n((apply-twice double) 5)\\\\n; expect 20\\\\n\\\\n((apply-twice (apply-twice double)) 5)\\\\n; expect 80\\\\n\\\\n(define fact (lambda (n) (if (<= n 1) 1 (* n (fact (- n 1))))))\\\\n(fact 3)\\\\n; expect 6\\\\n\\\\n(fact 50)\\\\n; expect 30414093201713378043612608166064768844377641568960512000000000000\\\\n\\\\n(define (combine f)\\\\n  (lambda (x y)\\\\n    (if (null? x) nil\\\\n      (f (list (car x) (car y))\\\\n         ((combine f) (cdr x) (cdr y))))))\\\\n(define zip (combine cons))\\\\n(zip (list 1 2 3 4) (list 5 6 7 8))\\\\n; expect ((1 5) (2 6) (3 7) (4 8))\\\\n\\\\n(define riff-shuffle (lambda (deck) (begin\\\\n    (define take (lambda (n seq) (if (<= n 0) (quote ()) (cons (car seq) (take (- n 1) (cdr seq))))))\\\\n    (define drop (lambda (n seq) (if (<= n 0) seq (drop (- n 1) (cdr seq)))))\\\\n    (define mid (lambda (seq) (/ (length seq) 2)))\\\\n    ((combine append) (take (mid deck) deck) (drop (mid deck) deck)))))\\\\n(riff-shuffle (list 1 2 3 4 5 6 7 8))\\\\n; expect (1 5 2 6 3 7 4 8)\\\\n\\\\n((apply-twice riff-shuffle) (list 1 2 3 4 5 6 7 8))\\\\n; expect (1 3 5 7 2 4 6 8)\\\\n\\\\n(riff-shuffle (riff-shuffle (riff-shuffle (list 1 2 3 4 5 6 7 8))))\\\\n; expect (1 2 3 4 5 6 7 8)\\\\n\\\\n;;; Additional tests\\\\n\\\\n(apply square \\\\'(2))\\\\n; expect 4\\\\n\\\\n(apply + \\\\'(1 2 3 4))\\\\n; expect 10\\\\n\\\\n(apply (if false + append) \\\\'((1 2) (3 4)))\\\\n; expect (1 2 3 4)\\\\n\\\\n(if 0 1 2)\\\\n; expect 1\\\\n\\\\n(if \\\\'() 1 2)\\\\n; expect 1\\\\n\\\\n(or false true)\\\\n; expect True\\\\n\\\\n(or)\\\\n; expect False\\\\n\\\\n(and)\\\\n; expect True\\\\n\\\\n(or 1 2 3)\\\\n; expect 1\\\\n\\\\n(and 1 2 3)\\\\n; expect 3\\\\n\\\\n(and False (/ 1 0))\\\\n; expect False\\\\n\\\\n(and True (/ 1 0))\\\\n; expect Error\\\\n\\\\n(or 3 (/ 1 0))\\\\n; expect 3\\\\n\\\\n(or False (/ 1 0))\\\\n; expect Error\\\\n\\\\n(or (quote hello) (quote world))\\\\n; expect hello\\\\n\\\\n(if nil 1 2)\\\\n; expect 1\\\\n\\\\n(if 0 1 2)\\\\n; expect 1\\\\n\\\\n(if (or false False #f) 1 2)\\\\n; expect 2\\\\n\\\\n(define (loop) (loop))\\\\n(cond (false (loop))\\\\n      (12))\\\\n; expect 12\\\\n\\\\n((lambda (x) (display x) (newline) x) 2)\\\\n; expect 2 ; 2\\\\n\\\\n(define g (mu () x))\\\\n(define (high f x)\\\\n  (f))\\\\n\\\\n(high g 2)\\\\n; expect 2\\\\n\\\\n(define (print-and-square x)\\\\n  (print x)\\\\n  (square x))\\\\n(print-and-square 12)\\\\n; expect 12 ; 144\\\\n\\\\n(/ 1 0)\\\\n; expect Error\\\\n\\\\n(define addx (mu (x) (+ x y)))\\\\n(define add2xy (lambda (x y) (addx (+ x x))))\\\\n(add2xy 3 7)\\\\n; expect 13\\\\n\\\\n\\\\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\\\\n;;; Scheme Implementations ;;;\\\\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\\\\n\\\\n;; len outputs the length of list s\\\\n(define (len s)\\\\n  (if (eq? s \\\\'())\\\\n    0\\\\n    (+ 1 (len (cdr s)))))\\\\n(len \\\\'(1 2 3 4))\\\\n; expect 4\\\\n\\\\n\\\\n;;;;;;;;;;;;;;;;;;;;\\\\n;;; Extra credit ;;;\\\\n;;;;;;;;;;;;;;;;;;;;\\\\n\\\\n(exit)\\\\n\\\\n; Tail call optimization tests\\\\n\\\\n(define (sum n total)\\\\n  (if (zero? n) total\\\\n    (sum (- n 1) (+ n total))))\\\\n(sum 1001 0)\\\\n; expect 501501\\\\n\\\\n(define (sum n total)\\\\n  (cond ((zero? n) total)\\\\n        (else (sum (- n 1) (+ n total)))))\\\\n(sum 1001 0)\\\\n; expect 501501\\\\n\\\\n(define (sum n total)\\\\n  (begin 2 3\\\\n    (if (zero? n) total\\\\n      (and 2 3\\\\n        (or false\\\\n          (begin 2 3\\\\n            (let ((m n))\\\\n              (sum (- m 1) (+ m total)))))))))\\\\n(sum 1001 0)\\\\n; expect 501501\\\\n\\\\n', 'scheme_reader.py': '\\\"\\\"\\\"This module implements the built-in data types of the Scheme language, along\\\\nwith a parser for Scheme expressions.\\\\n\\\\nIn addition to the types defined in this file, some data types in Scheme are\\\\nrepresented by their corresponding type in Python:\\\\n    number:       int or float\\\\n    symbol:       string\\\\n    boolean:      bool\\\\n    unspecified:  None\\\\n\\\\nThe __repr__ method of a Scheme value will return a Python expression that\\\\nwould be evaluated to the value, where possible.\\\\n\\\\nThe __str__ method of a Scheme value will return a Scheme expression that\\\\nwould be read to the value, where possible.\\\\n\\\"\\\"\\\"\\\\n\\\\nfrom ucb import main, trace, interact\\\\nfrom scheme_tokens import tokenize_lines, DELIMITERS\\\\nfrom buffer import Buffer, InputReader, LineReader\\\\n\\\\n# Pairs and Scheme lists\\\\n\\\\nclass Pair:\\\\n    \\\"\\\"\\\"A pair has two instance attributes: first and second.  For a Pair to be\\\\n    a well-formed list, second is either a well-formed list or nil.  Some\\\\n    methods only apply to well-formed lists.\\\\n\\\\n    >>> s = Pair(1, Pair(2, nil))\\\\n    >>> s\\\\n    Pair(1, Pair(2, nil))\\\\n    >>> print(s)\\\\n    (1 2)\\\\n    >>> print(s.map(lambda x: x+4))\\\\n    (5 6)\\\\n    \\\"\\\"\\\"\\\\n    def __init__(self, first, second):\\\\n        self.first = first\\\\n        self.second = second\\\\n\\\\n    def __repr__(self):\\\\n        return \\\"Pair({0}, {1})\\\".format(repr(self.first), repr(self.second))\\\\n\\\\n    def __str__(self):\\\\n        s = \\\"(\\\" + str(self.first)\\\\n        second = self.second\\\\n        while isinstance(second, Pair):\\\\n            s += \\\" \\\" + str(second.first)\\\\n            second = second.second\\\\n        if second is not nil:\\\\n            s += \\\" . \\\" + str(second)\\\\n        return s + \\\")\\\"\\\\n\\\\n    def __len__(self):\\\\n        n, second = 1, self.second\\\\n        while isinstance(second, Pair):\\\\n            n += 1\\\\n            second = second.second\\\\n        if second is not nil:\\\\n            raise TypeError(\\\"length attempted on improper list\\\")\\\\n        return n\\\\n\\\\n    def __eq__(self, p):\\\\n        if not isinstance(p, Pair):\\\\n            return False\\\\n        return self.first == p.first and self.second == p.second\\\\n\\\\n    def map(self, fn):\\\\n        \\\"\\\"\\\"Return a Scheme list after mapping Python function FN to SELF.\\\"\\\"\\\"\\\\n        mapped = fn(self.first)\\\\n        if self.second is nil or isinstance(self.second, Pair):\\\\n            return Pair(mapped, self.second.map(fn))\\\\n        else:\\\\n            raise TypeError(\\\"ill-formed list\\\")\\\\n\\\\nclass nil:\\\\n    \\\"\\\"\\\"The empty list\\\"\\\"\\\"\\\\n\\\\n    def __repr__(self):\\\\n        return \\\"nil\\\"\\\\n\\\\n    def __str__(self):\\\\n        return \\\"()\\\"\\\\n\\\\n    def __len__(self):\\\\n        return 0\\\\n\\\\n    def map(self, fn):\\\\n        return self\\\\n\\\\nnil = nil() # Assignment hides the nil class; there is only one instance\\\\n\\\\n# Scheme list parser\\\\n\\\\n\\\\ndef scheme_read(src):\\\\n    \\\"\\\"\\\"Read the next expression from SRC, a Buffer of tokens.\\\\n\\\\n    >>> lines = [\\\"(+ 1 \\\", \\\"(+ 23 4)) (\\\"]\\\\n    >>> src = Buffer(tokenize_lines(lines))\\\\n    >>> print(scheme_read(src))\\\\n    (+ 1 (+ 23 4))\\\\n    >>> read_line(\\\"\\\\'hello\\\")\\\\n    Pair(\\\\'quote\\\\', Pair(\\\\'hello\\\\', nil))\\\\n    >>> print(read_line(\\\"(car \\\\'(1 2))\\\"))\\\\n    (car (quote (1 2)))\\\\n    \\\"\\\"\\\"\\\\n    if src.current() is None:\\\\n        raise EOFError\\\\n    val = src.pop()\\\\n    if val == \\\"nil\\\":\\\\n        return nil\\\\n    elif val not in DELIMITERS:\\\\n        return val\\\\n    elif val == \\\"\\\\'\\\":\\\\n        # BEGIN Question 1\\\\n        \\\"*** REPLACE THIS LINE ***\\\"\\\\n        # END Question 1\\\\n    elif val == \\\"(\\\":\\\\n        return read_tail(src)\\\\n    else:\\\\n        raise SyntaxError(\\\"unexpected token: {0}\\\".format(val))\\\\n\\\\ndef read_tail(src):\\\\n    \\\"\\\"\\\"Return the remainder of a list in SRC, starting before an element or ).\\\\n\\\\n    >>> read_tail(Buffer(tokenize_lines([\\\")\\\"])))\\\\n    nil\\\\n    >>> read_tail(Buffer(tokenize_lines([\\\"2 3)\\\"])))\\\\n    Pair(2, Pair(3, nil))\\\\n    >>> read_tail(Buffer(tokenize_lines([\\\"2 (3 4))\\\"])))\\\\n    Pair(2, Pair(Pair(3, Pair(4, nil)), nil))\\\\n    >>> read_line(\\\"(1 . 2)\\\")\\\\n    Pair(1, 2)\\\\n    >>> read_line(\\\"(1 2 . 3)\\\")\\\\n    Pair(1, Pair(2, 3))\\\\n    >>> read_line(\\\"(1 . 2 3)\\\")\\\\n    Traceback (most recent call last):\\\\n      ...\\\\n    SyntaxError: expected one element after .\\\\n    >>> scheme_read(Buffer(tokenize_lines([\\\"(1\\\", \\\"2 .\\\", \\\"\\\\'(3 4))\\\", \\\"4\\\"])))\\\\n    Pair(1, Pair(2, Pair(\\\\'quote\\\\', Pair(Pair(3, Pair(4, nil)), nil))))\\\\n    \\\"\\\"\\\"\\\\n    try:\\\\n        if src.current() is None:\\\\n            raise SyntaxError(\\\"unexpected end of file\\\")\\\\n        elif src.current() == \\\")\\\":\\\\n            src.pop()\\\\n            return nil\\\\n        elif src.current() == \\\".\\\":\\\\n            # BEGIN Question 2\\\\n            \\\"*** REPLACE THIS LINE ***\\\"\\\\n            # END Question 2\\\\n        else:\\\\n            first = scheme_read(src)\\\\n            rest = read_tail(src)\\\\n            return Pair(first, rest)\\\\n    except EOFError:\\\\n        raise SyntaxError(\\\"unexpected end of file\\\")\\\\n\\\\n# Convenience methods\\\\n\\\\ndef buffer_input(prompt=\\\"scm> \\\"):\\\\n    \\\"\\\"\\\"Return a Buffer instance containing interactive input.\\\"\\\"\\\"\\\\n    return Buffer(tokenize_lines(InputReader(prompt)))\\\\n\\\\ndef buffer_lines(lines, prompt=\\\"scm> \\\", show_prompt=False):\\\\n    \\\"\\\"\\\"Return a Buffer instance iterating through LINES.\\\"\\\"\\\"\\\\n    if show_prompt:\\\\n        input_lines = lines\\\\n    else:\\\\n        input_lines = LineReader(lines, prompt)\\\\n    return Buffer(tokenize_lines(input_lines))\\\\n\\\\ndef read_line(line):\\\\n    \\\"\\\"\\\"Read a single string LINE as a Scheme expression.\\\"\\\"\\\"\\\\n    return scheme_read(Buffer(tokenize_lines([line])))\\\\n\\\\n# Interactive loop\\\\n\\\\n@main\\\\ndef read_print_loop():\\\\n    \\\"\\\"\\\"Run a read-print loop for Scheme expressions.\\\"\\\"\\\"\\\\n    while True:\\\\n        try:\\\\n            src = buffer_input(\\\"read> \\\")\\\\n            while src.more_on_line:\\\\n                expression = scheme_read(src)\\\\n                print(\\\"str :\\\", expression)\\\\n                print(\\\"repr:\\\", repr(expression))\\\\n        except (SyntaxError, ValueError) as err:\\\\n            print(type(err).__name__ + \\\":\\\", err)\\\\n        except (KeyboardInterrupt, EOFError):  # <Control>-D, etc.\\\\n            print()\\\\n            return\\\\n', 'questions.scm': \\\"(define (caar x) (car (car x)))\\\\n(define (cadr x) (car (cdr x)))\\\\n(define (cddr x) (cdr (cdr x)))\\\\n(define (cadar x) (car (cdr (car x))))\\\\n\\\\n; Some utility functions that you may find useful to implement.\\\\n(define (map proc items)\\\\n  'REPLACE-THIS-LINE)\\\\n\\\\n(define (cons-all first rests)\\\\n  'REPLACE-THIS-LINE)\\\\n\\\\n(define (zip pairs)\\\\n  'REPLACE-THIS-LINE)\\\\n\\\\n;; Problem 18\\\\n;; Returns a list of two-element lists\\\\n(define (enumerate s)\\\\n  ; BEGIN Question 18\\\\n  'REPLACE-THIS-LINE\\\\n  )\\\\n  ; END Question 18\\\\n\\\\n;; Problem 19\\\\n;; List all ways to make change for TOTAL with DENOMS\\\\n(define (list-change total denoms)\\\\n  ; BEGIN Question 19\\\\n  'REPLACE-THIS-LINE\\\\n  )\\\\n  ; END Question 19\\\\n\\\\n;; Problem 20\\\\n;; Returns a function that checks if an expression is the special form FORM\\\\n(define (check-special form)\\\\n  (lambda (expr) (equal? form (car expr))))\\\\n\\\\n(define lambda? (check-special 'lambda))\\\\n(define define? (check-special 'define))\\\\n(define quoted? (check-special 'quote))\\\\n(define let?    (check-special 'let))\\\\n\\\\n;; Converts all let special forms in EXPR into equivalent forms using lambda\\\\n(define (analyze expr)\\\\n  (cond ((atom? expr)\\\\n         ; BEGIN Question 20\\\\n         'REPLACE-THIS-LINE\\\\n         ; END Question 20\\\\n         )\\\\n        ((quoted? expr)\\\\n         ; BEGIN Question 20\\\\n         'REPLACE-THIS-LINE\\\\n         ; END Question 20\\\\n         )\\\\n        ((or (lambda? expr)\\\\n             (define? expr))\\\\n         (let ((form   (car expr))\\\\n               (params (cadr expr))\\\\n               (body   (cddr expr)))\\\\n           ; BEGIN Question 20\\\\n           'REPLACE-THIS-LINE\\\\n           ; END Question 20\\\\n           ))\\\\n        ((let? expr)\\\\n         (let ((values (cadr expr))\\\\n               (body   (cddr expr)))\\\\n           ; BEGIN Question 20\\\\n           'REPLACE-THIS-LINE\\\\n           ; END Question 20\\\\n           ))\\\\n        (else\\\\n         ; BEGIN Question 20\\\\n         'REPLACE-THIS-LINE\\\\n         ; END Question 20\\\\n         )))\\\\n\\\\n;; Problem 21 (optional)\\\\n;; Draw the hax image using turtle graphics.\\\\n(define (hax d k)\\\\n  ; BEGIN Question 21\\\\n  'REPLACE-THIS-LINE\\\\n  )\\\\n  ; END Question 21\\\\n\\\\n\\\"}\"",
        "url": null
    },
    "client_time": null,
    "created": "2015-11-19 22:49:03.698403",
    "id": 6266017535754240,
    "messages": {
        "analytics": {
            "started": {
                "Extra Credit": true,
                "Question 1": true,
                "Question 11B": true,
                "Question 12": true,
                "Question 13": true,
                "Question 14B": true,
                "Question 15A": true,
                "Question 16": true,
                "Question 17": true,
                "Question 18": true,
                "Question 19": true,
                "Question 2": true,
                "Question 20": true,
                "Question 21": true,
                "Question 3": true,
                "Question 4": true,
                "Question 5A": true,
                "Question 6B": true,
                "Question 7": true,
                "Question 8": true,
                "Question 9A": true
            },
            "time": "2015-11-19 23:49:03.698403",
            "unlock": false
        },
        "file_contents": {
            "group_members_6052407744135168.json": "{\n    \"0\": \"bowenwang@berkeley.edu\",\n    \"1\": \"t.h.wang@berkeley.edu\"\n}",
            "group_meta_6052407744135168.json": "{\n    \"assignment\": {\n        \"active\": false,\n        \"autograding_enabled\": true,\n        \"autograding_key\": \"\",\n        \"course\": {\n            \"active\": true,\n            \"created\": \"2015-08-24 20:37:42.000000\",\n            \"display_name\": \"CS 61A\",\n            \"id\": 5631829415559168,\n            \"institution\": \"UC Berkeley\",\n            \"instructor\": [],\n            \"offering\": \"cal/cs61a/fa15\"\n        },\n        \"created\": \"2015-11-03 22:18:40.904230\",\n        \"creator\": {\n            \"created\": \"2015-01-23 09:10:24.000000\",\n            \"email\": [\n                \"sumukh@berkeley.edu\"\n            ],\n            \"id\": 5644720948641792,\n            \"is_admin\": true\n        },\n        \"display_name\": \"Scheme\",\n        \"due_date\": \"2015-11-19 23:59:59.000000\",\n        \"id\": 5300076173852672,\n        \"lock_date\": \"2015-11-22 23:59:59.000000\",\n        \"max_group_size\": 2,\n        \"name\": \"cal/cs61a/fa15/proj4\",\n        \"points\": 28.0,\n        \"revision\": false,\n        \"templates\": \"\\\"{'scheme.py': '\\\\\\\"\\\\\\\"\\\\\\\"A Scheme interpreter and its read-eval-print loop.\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\\n\\\\\\\\nfrom scheme_primitives import *\\\\\\\\nfrom scheme_reader import *\\\\\\\\nfrom ucb import main, trace\\\\\\\\n\\\\\\\\n##############\\\\\\\\n# Eval/Apply #\\\\\\\\n##############\\\\\\\\n\\\\\\\\ndef scheme_eval(expr, env, _=None): # Optional third argument is ignored\\\\\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"Evaluate Scheme expression EXPR in environment ENV.\\\\\\\\n\\\\\\\\n    >>> expr = read_line(\\\\\\\"(+ 2 2)\\\\\\\")\\\\\\\\n    >>> expr\\\\\\\\n    Pair(\\\\\\\\'+\\\\\\\\', Pair(2, Pair(2, nil)))\\\\\\\\n    >>> scheme_eval(expr, create_global_frame())\\\\\\\\n    4\\\\\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\\n    # Atoms\\\\\\\\n    assert expr is not None\\\\\\\\n    if scheme_symbolp(expr):\\\\\\\\n        return env.lookup(expr)\\\\\\\\n    elif self_evaluating(expr):\\\\\\\\n        return expr\\\\\\\\n\\\\\\\\n    # Combinations\\\\\\\\n    if not scheme_listp(expr):\\\\\\\\n        raise SchemeError(\\\\\\\"malformed list: {0}\\\\\\\".format(str(expr)))\\\\\\\\n    first, rest = expr.first, expr.second\\\\\\\\n    if scheme_symbolp(first) and first in SPECIAL_FORMS:\\\\\\\\n        result = SPECIAL_FORMS[first](rest, env)\\\\\\\\n    else:\\\\\\\\n        procedure = scheme_eval(first, env)\\\\\\\\n        args = rest.map(lambda operand: scheme_eval(operand, env))\\\\\\\\n        result = scheme_apply(procedure, args, env)\\\\\\\\n    return result\\\\\\\\n\\\\\\\\ndef self_evaluating(expr):\\\\\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"Return whether EXPR evaluates to itself.\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\\n    return scheme_atomp(expr) or scheme_stringp(expr) or expr is okay\\\\\\\\n\\\\\\\\n\\\\\\\\ndef scheme_apply(procedure, args, env):\\\\\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"Apply Scheme PROCEDURE to argument values ARGS in environment ENV.\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\\n    if isinstance(procedure, PrimitiveProcedure):\\\\\\\\n        return apply_primitive(procedure, args, env)\\\\\\\\n    elif isinstance(procedure, UserDefinedProcedure):\\\\\\\\n        new_env = make_call_frame(procedure, args, env)\\\\\\\\n        return eval_all(procedure.body, new_env)\\\\\\\\n    else:\\\\\\\\n        raise SchemeError(\\\\\\\"cannot call: {0}\\\\\\\".format(str(procedure)))\\\\\\\\n\\\\\\\\ndef apply_primitive(procedure, args_scheme_list, env):\\\\\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"Apply PrimitiveProcedure PROCEDURE to ARGS_SCHEME_LIST in ENV.\\\\\\\\n\\\\\\\\n    >>> env = create_global_frame()\\\\\\\\n    >>> plus = env.bindings[\\\\\\\"+\\\\\\\"]\\\\\\\\n    >>> twos = Pair(2, Pair(2, nil))\\\\\\\\n    >>> apply_primitive(plus, twos, env)\\\\\\\\n    4\\\\\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\\n    # Convert a Scheme list to a Python list\\\\\\\\n    args = []\\\\\\\\n    while args_scheme_list is not nil:\\\\\\\\n        args.append(args_scheme_list.first)\\\\\\\\n        args_scheme_list = args_scheme_list.second\\\\\\\\n    # BEGIN Question 4\\\\\\\\n    \\\\\\\"*** REPLACE THIS LINE ***\\\\\\\"\\\\\\\\n    # END Question 4\\\\\\\\n\\\\\\\\ndef eval_all(expressions, env):\\\\\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"Evaluate a Scheme list of EXPRESSIONS & return the value of the last.\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\\n    # BEGIN Question 7\\\\\\\\n    \\\\\\\"*** REPLACE THIS LINE ***\\\\\\\"\\\\\\\\n    return scheme_eval(expressions.first, env)\\\\\\\\n    # END Question 7\\\\\\\\n\\\\\\\\ndef make_call_frame(procedure, args, env):\\\\\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"Make a frame that binds the formal parameters of PROCEDURE to ARGS.\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\\n    # BEGIN Question 12\\\\\\\\n    \\\\\\\"*** REPLACE THIS LINE ***\\\\\\\"\\\\\\\\n    # END Question 12\\\\\\\\n\\\\\\\\n################\\\\\\\\n# Environments #\\\\\\\\n################\\\\\\\\n\\\\\\\\nclass Frame:\\\\\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"An environment frame binds Scheme symbols to Scheme values.\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\\n\\\\\\\\n    def __init__(self, parent):\\\\\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"An empty frame with a PARENT frame (which may be None).\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\\n        self.bindings = {}\\\\\\\\n        self.parent = parent\\\\\\\\n\\\\\\\\n    def __repr__(self):\\\\\\\\n        if self.parent is None:\\\\\\\\n            return \\\\\\\"<Global Frame>\\\\\\\"\\\\\\\\n        else:\\\\\\\\n            s = sorted(\\\\\\\\'{0}: {1}\\\\\\\\'.format(k,v) for k,v in self.bindings.items())\\\\\\\\n            return \\\\\\\"<{{{0}}} -> {1}>\\\\\\\".format(\\\\\\\\', \\\\\\\\'.join(s), repr(self.parent))\\\\\\\\n\\\\\\\\n    def lookup(self, symbol):\\\\\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"Return the value bound to SYMBOL.  Errors if SYMBOL is not found.\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\\n        # BEGIN Question 3\\\\\\\\n        \\\\\\\"*** REPLACE THIS LINE ***\\\\\\\"\\\\\\\\n        # END Question 3\\\\\\\\n        raise SchemeError(\\\\\\\"unknown identifier: {0}\\\\\\\".format(symbol))\\\\\\\\n\\\\\\\\n    def make_child_frame(self, formals, vals):\\\\\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"Return a new local frame whose parent is SELF, in which the symbols\\\\\\\\n        in a Scheme list of formal parameters FORMALS are bound to the Scheme\\\\\\\\n        values in the Scheme list VALS. Raise an error if too many or too few\\\\\\\\n        vals are given.\\\\\\\\n\\\\\\\\n        >>> env = create_global_frame()\\\\\\\\n        >>> formals, expressions = read_line(\\\\\\\"(a b c)\\\\\\\"), read_line(\\\\\\\"(1 2 3)\\\\\\\")\\\\\\\\n        >>> env.make_child_frame(formals, expressions)\\\\\\\\n        <{a: 1, b: 2, c: 3} -> <Global Frame>>\\\\\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\\n        child = Frame(self) # Create a new child with self as the parent\\\\\\\\n        # BEGIN Question 10\\\\\\\\n        \\\\\\\"*** REPLACE THIS LINE ***\\\\\\\"\\\\\\\\n        # END Question 10\\\\\\\\n        return child\\\\\\\\n\\\\\\\\n    def define(self, symbol, value):\\\\\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"Define Scheme SYMBOL to have VALUE.\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\\n        self.bindings[symbol] = value\\\\\\\\n\\\\\\\\nclass UserDefinedProcedure:\\\\\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"A procedure defined by an expression.\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\\n\\\\\\\\nclass LambdaProcedure(UserDefinedProcedure):\\\\\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"A procedure defined by a lambda expression or a define form.\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\\n\\\\\\\\n    def __init__(self, formals, body, env):\\\\\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"A procedure with formal parameter list FORMALS (a Scheme list),\\\\\\\\n        a Scheme list of BODY expressions, and a parent environment that\\\\\\\\n        starts with Frame ENV.\\\\\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\\n        self.formals = formals\\\\\\\\n        self.body = body\\\\\\\\n        self.env = env\\\\\\\\n\\\\\\\\n    def __str__(self):\\\\\\\\n        return str(Pair(\\\\\\\"lambda\\\\\\\", Pair(self.formals, self.body)))\\\\\\\\n\\\\\\\\n    def __repr__(self):\\\\\\\\n        return \\\\\\\"LambdaProcedure({!r}, {!r}, {!r})\\\\\\\".format(\\\\\\\\n            self.formals, self.body, self.env)\\\\\\\\n\\\\\\\\n#################\\\\\\\\n# Special forms #\\\\\\\\n#################\\\\\\\\n\\\\\\\\ndef do_define_form(expressions, env):\\\\\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"Evaluate a define form.\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\\n    check_form(expressions, 2)\\\\\\\\n    target = expressions.first\\\\\\\\n    if scheme_symbolp(target):\\\\\\\\n        check_form(expressions, 2, 2)\\\\\\\\n        # BEGIN Question 5A\\\\\\\\n        \\\\\\\"*** REPLACE THIS LINE ***\\\\\\\"\\\\\\\\n        # END Question 5A\\\\\\\\n    elif isinstance(target, Pair) and scheme_symbolp(target.first):\\\\\\\\n        # BEGIN Question 9A\\\\\\\\n        \\\\\\\"*** REPLACE THIS LINE ***\\\\\\\"\\\\\\\\n        # END Question 9A\\\\\\\\n    else:\\\\\\\\n        bad = target.first if isinstance(target, Pair) else target\\\\\\\\n        raise SchemeError(\\\\\\\"Non-symbol: {}\\\\\\\".format(bad))\\\\\\\\n\\\\\\\\ndef do_quote_form(expressions, env):\\\\\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"Evaluate a quote form.\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\\n    check_form(expressions, 1, 1)\\\\\\\\n    # BEGIN Question 6B\\\\\\\\n    \\\\\\\"*** REPLACE THIS LINE ***\\\\\\\"\\\\\\\\n    # END Question 6B\\\\\\\\n\\\\\\\\ndef do_begin_form(expressions, env):\\\\\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"Evaluate begin form.\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\\n    check_form(expressions, 1)\\\\\\\\n    return eval_all(expressions, env)\\\\\\\\n\\\\\\\\ndef do_lambda_form(expressions, env):\\\\\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"Evaluate a lambda form.\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\\n    check_form(expressions, 2)\\\\\\\\n    formals = expressions.first\\\\\\\\n    check_formals(formals)\\\\\\\\n    # BEGIN Question 8\\\\\\\\n    \\\\\\\"*** REPLACE THIS LINE ***\\\\\\\"\\\\\\\\n    # END Question 8\\\\\\\\n\\\\\\\\ndef do_if_form(expressions, env):\\\\\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"Evaluate an if form.\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\\n    check_form(expressions, 2, 3)\\\\\\\\n    # BEGIN Question 13\\\\\\\\n    \\\\\\\"*** REPLACE THIS LINE ***\\\\\\\"\\\\\\\\n    # END Question 13\\\\\\\\n\\\\\\\\ndef do_and_form(expressions, env):\\\\\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"Evaluate a short-circuited and form.\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\\n    # BEGIN Question 14B\\\\\\\\n    \\\\\\\"*** REPLACE THIS LINE ***\\\\\\\"\\\\\\\\n    # END Question 14B\\\\\\\\n\\\\\\\\ndef do_or_form(expressions, env):\\\\\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"Evaluate a short-circuited or form.\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\\n    # BEGIN Question 14B\\\\\\\\n    \\\\\\\"*** REPLACE THIS LINE ***\\\\\\\"\\\\\\\\n    # END Question 14B\\\\\\\\n\\\\\\\\ndef do_cond_form(expressions, env):\\\\\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"Evaluate a cond form.\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\\n    num_clauses = len(expressions)\\\\\\\\n    i = 0\\\\\\\\n    while expressions is not nil:\\\\\\\\n        clause = expressions.first\\\\\\\\n        check_form(clause, 1)\\\\\\\\n        if clause.first == \\\\\\\"else\\\\\\\":\\\\\\\\n            if i < num_clauses-1:\\\\\\\\n                raise SchemeError(\\\\\\\"else must be last\\\\\\\")\\\\\\\\n            test = True\\\\\\\\n        else:\\\\\\\\n            test = scheme_eval(clause.first, env)\\\\\\\\n        if scheme_true(test):\\\\\\\\n            # BEGIN Question 15A\\\\\\\\n            \\\\\\\"*** REPLACE THIS LINE ***\\\\\\\"\\\\\\\\n            # END Question 15A\\\\\\\\n        expressions = expressions.second\\\\\\\\n        i += 1\\\\\\\\n    return okay\\\\\\\\n\\\\\\\\ndef do_let_form(expressions, env):\\\\\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"Evaluate a let form.\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\\n    check_form(expressions, 2)\\\\\\\\n    let_env = make_let_frame(expressions.first, env)\\\\\\\\n    return eval_all(expressions.second, let_env)\\\\\\\\n\\\\\\\\ndef make_let_frame(bindings, env):\\\\\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"Create a frame containing bindings from a let expression.\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\\n    if not scheme_listp(bindings):\\\\\\\\n        raise SchemeError(\\\\\\\"bad bindings list in let form\\\\\\\")\\\\\\\\n    # BEGIN Question 16\\\\\\\\n    \\\\\\\"*** REPLACE THIS LINE ***\\\\\\\"\\\\\\\\n    # END Question 16\\\\\\\\n\\\\\\\\nSPECIAL_FORMS = {\\\\\\\\n    \\\\\\\"and\\\\\\\": do_and_form,\\\\\\\\n    \\\\\\\"begin\\\\\\\": do_begin_form,\\\\\\\\n    \\\\\\\"cond\\\\\\\": do_cond_form,\\\\\\\\n    \\\\\\\"define\\\\\\\": do_define_form,\\\\\\\\n    \\\\\\\"if\\\\\\\": do_if_form,\\\\\\\\n    \\\\\\\"lambda\\\\\\\": do_lambda_form,\\\\\\\\n    \\\\\\\"let\\\\\\\": do_let_form,\\\\\\\\n    \\\\\\\"or\\\\\\\": do_or_form,\\\\\\\\n    \\\\\\\"quote\\\\\\\": do_quote_form,\\\\\\\\n}\\\\\\\\n\\\\\\\\n# Utility methods for checking the structure of Scheme programs\\\\\\\\n\\\\\\\\ndef check_form(expr, min, max=float(\\\\\\\\'inf\\\\\\\\')):\\\\\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"Check EXPR is a proper list whose length is at least MIN and no more\\\\\\\\n    than MAX (default: no maximum). Raises a SchemeError if this is not the\\\\\\\\n    case.\\\\\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\\n    if not scheme_listp(expr):\\\\\\\\n        raise SchemeError(\\\\\\\"badly formed expression: \\\\\\\" + str(expr))\\\\\\\\n    length = len(expr)\\\\\\\\n    if length < min:\\\\\\\\n        raise SchemeError(\\\\\\\"too few operands in form\\\\\\\")\\\\\\\\n    elif length > max:\\\\\\\\n        raise SchemeError(\\\\\\\"too many operands in form\\\\\\\")\\\\\\\\n\\\\\\\\ndef check_formals(formals):\\\\\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"Check that FORMALS is a valid parameter list, a Scheme list of symbols\\\\\\\\n    in which each symbol is distinct. Raise a SchemeError if the list of\\\\\\\\n    formals is not a well-formed list of symbols or if any symbol is repeated.\\\\\\\\n\\\\\\\\n    >>> check_formals(read_line(\\\\\\\"(a b c)\\\\\\\"))\\\\\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\\n    # BEGIN Question 11B\\\\\\\\n    \\\\\\\"*** REPLACE THIS LINE ***\\\\\\\"\\\\\\\\n    # END Question 11B\\\\\\\\n\\\\\\\\n#################\\\\\\\\n# Dynamic Scope #\\\\\\\\n#################\\\\\\\\n\\\\\\\\nclass MuProcedure(UserDefinedProcedure):\\\\\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"A procedure defined by a mu expression, which has dynamic scope.\\\\\\\\n     _________________\\\\\\\\n    < Scheme is cool! >\\\\\\\\n     -----------------\\\\\\\\n            \\\\\\\\\\\\\\\\   ^__^\\\\\\\\n             \\\\\\\\\\\\\\\\  (oo)\\\\\\\\\\\\\\\\_______\\\\\\\\n                (__)\\\\\\\\\\\\\\\\       )\\\\\\\\\\\\\\\\/\\\\\\\\\\\\\\\\\\\\\\\\n                    ||----w |\\\\\\\\n                    ||     ||\\\\\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\\n\\\\\\\\n    def __init__(self, formals, body):\\\\\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"A procedure with formal parameter list FORMALS (a Scheme list) and a\\\\\\\\n        Scheme list of BODY expressions.\\\\\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\\n        self.formals = formals\\\\\\\\n        self.body = body\\\\\\\\n\\\\\\\\n    def __str__(self):\\\\\\\\n        return str(Pair(\\\\\\\"mu\\\\\\\", Pair(self.formals, self.body)))\\\\\\\\n\\\\\\\\n    def __repr__(self):\\\\\\\\n        return \\\\\\\"MuProcedure({!r}, {!r})\\\\\\\".format(self.formals, self.body)\\\\\\\\n\\\\\\\\n\\\\\\\\ndef do_mu_form(expressions, env):\\\\\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"Evaluate a mu form.\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\\n    check_form(expressions, 2)\\\\\\\\n    formals = expressions.first\\\\\\\\n    check_formals(formals)\\\\\\\\n    # BEGIN Question 17\\\\\\\\n    \\\\\\\"*** REPLACE THIS LINE ***\\\\\\\"\\\\\\\\n    # END Question 17\\\\\\\\n\\\\\\\\nSPECIAL_FORMS[\\\\\\\"mu\\\\\\\"] = do_mu_form\\\\\\\\n\\\\\\\\n\\\\\\\\n##################\\\\\\\\n# Tail Recursion #\\\\\\\\n##################\\\\\\\\n\\\\\\\\nclass Evaluate:\\\\\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"An expression EXPR to be evaluated in environment ENV.\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\\n    def __init__(self, expr, env):\\\\\\\\n        self.expr = expr\\\\\\\\n        self.env = env\\\\\\\\n\\\\\\\\ndef scheme_optimized_eval(expr, env, tail=False):\\\\\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"Evaluate Scheme expression EXPR in environment ENV.\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\\n    # Evaluate Atoms\\\\\\\\n    assert expr is not None\\\\\\\\n    if scheme_symbolp(expr):\\\\\\\\n        return env.lookup(expr)\\\\\\\\n    elif self_evaluating(expr):\\\\\\\\n        return expr\\\\\\\\n\\\\\\\\n    if tail:\\\\\\\\n        # BEGIN Extra Credit\\\\\\\\n        \\\\\\\"*** REPLACE THIS LINE ***\\\\\\\"\\\\\\\\n        # END Extra Credit\\\\\\\\n    else:\\\\\\\\n        result = Evaluate(expr, env)\\\\\\\\n\\\\\\\\n    while isinstance(result, Evaluate):\\\\\\\\n        expr, env = result.expr, result.env\\\\\\\\n        # All non-atomic expressions are lists (combinations)\\\\\\\\n        if not scheme_listp(expr):\\\\\\\\n            raise SchemeError(\\\\\\\"malformed list: {0}\\\\\\\".format(str(expr)))\\\\\\\\n        first, rest = expr.first, expr.second\\\\\\\\n        if (scheme_symbolp(first) and first in SPECIAL_FORMS):\\\\\\\\n            result = SPECIAL_FORMS[first](rest, env)\\\\\\\\n        else:\\\\\\\\n            procedure = scheme_eval(first, env)\\\\\\\\n            args = rest.map(lambda operand: scheme_eval(operand, env))\\\\\\\\n            result = scheme_apply(procedure, args, env)\\\\\\\\n    return result\\\\\\\\n\\\\\\\\n################################################################\\\\\\\\n# Uncomment the following line to apply tail call optimization #\\\\\\\\n################################################################\\\\\\\\n# scheme_eval = scheme_optimized_eval\\\\\\\\n\\\\\\\\n\\\\\\\\n################\\\\\\\\n# Input/Output #\\\\\\\\n################\\\\\\\\n\\\\\\\\ndef read_eval_print_loop(next_line, env, interactive=False, quiet=False,\\\\\\\\n                         startup=False, load_files=()):\\\\\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"Read and evaluate input until an end of file or keyboard interrupt.\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\\n    if startup:\\\\\\\\n        for filename in load_files:\\\\\\\\n            scheme_load(filename, True, env)\\\\\\\\n    while True:\\\\\\\\n        try:\\\\\\\\n            src = next_line()\\\\\\\\n            while src.more_on_line:\\\\\\\\n                expression = scheme_read(src)\\\\\\\\n                result = scheme_eval(expression, env)\\\\\\\\n                if not quiet and result is not None:\\\\\\\\n                    print(result)\\\\\\\\n        except (SchemeError, SyntaxError, ValueError, RuntimeError) as err:\\\\\\\\n            if (isinstance(err, RuntimeError) and\\\\\\\\n                \\\\\\\\'maximum recursion depth exceeded\\\\\\\\' not in getattr(err, \\\\\\\\'args\\\\\\\\')[0]):\\\\\\\\n                raise\\\\\\\\n            elif isinstance(err, RuntimeError):\\\\\\\\n                print(\\\\\\\"Error: maximum recursion depth exceeded\\\\\\\")\\\\\\\\n            else:\\\\\\\\n                print(\\\\\\\"Error:\\\\\\\", err)\\\\\\\\n        except KeyboardInterrupt:  # <Control>-C\\\\\\\\n            if not startup:\\\\\\\\n                raise\\\\\\\\n            print()\\\\\\\\n            print(\\\\\\\"KeyboardInterrupt\\\\\\\")\\\\\\\\n            if not interactive:\\\\\\\\n                return\\\\\\\\n        except EOFError:  # <Control>-D, etc.\\\\\\\\n            print()\\\\\\\\n            return\\\\\\\\n\\\\\\\\ndef scheme_load(*args):\\\\\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"Load a Scheme source file. ARGS should be of the form (SYM, ENV) or (SYM,\\\\\\\\n    QUIET, ENV). The file named SYM is loaded in environment ENV, with verbosity\\\\\\\\n    determined by QUIET (default true).\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\\n    if not (2 <= len(args) <= 3):\\\\\\\\n        expressions = args[:-1]\\\\\\\\n        raise SchemeError(\\\\\\\\'\\\\\\\"load\\\\\\\" given incorrect number of arguments: \\\\\\\\'\\\\\\\\n                          \\\\\\\\'{0}\\\\\\\\'.format(len(expressions)))\\\\\\\\n    sym = args[0]\\\\\\\\n    quiet = args[1] if len(args) > 2 else True\\\\\\\\n    env = args[-1]\\\\\\\\n    if (scheme_stringp(sym)):\\\\\\\\n        sym = eval(sym)\\\\\\\\n    check_type(sym, scheme_symbolp, 0, \\\\\\\"load\\\\\\\")\\\\\\\\n    with scheme_open(sym) as infile:\\\\\\\\n        lines = infile.readlines()\\\\\\\\n    args = (lines, None) if quiet else (lines,)\\\\\\\\n    def next_line():\\\\\\\\n        return buffer_lines(*args)\\\\\\\\n\\\\\\\\n    read_eval_print_loop(next_line, env, quiet=quiet)\\\\\\\\n    return okay\\\\\\\\n\\\\\\\\ndef scheme_open(filename):\\\\\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"If either FILENAME or FILENAME.scm is the name of a valid file,\\\\\\\\n    return a Python file opened to it. Otherwise, raise an error.\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\\n    try:\\\\\\\\n        return open(filename)\\\\\\\\n    except IOError as exc:\\\\\\\\n        if filename.endswith(\\\\\\\\'.scm\\\\\\\\'):\\\\\\\\n            raise SchemeError(str(exc))\\\\\\\\n    try:\\\\\\\\n        return open(filename + \\\\\\\\'.scm\\\\\\\\')\\\\\\\\n    except IOError as exc:\\\\\\\\n        raise SchemeError(str(exc))\\\\\\\\n\\\\\\\\ndef create_global_frame():\\\\\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"Initialize and return a single-frame environment with built-in names.\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\\n    env = Frame(None)\\\\\\\\n    env.define(\\\\\\\"eval\\\\\\\", PrimitiveProcedure(scheme_eval, True))\\\\\\\\n    env.define(\\\\\\\"apply\\\\\\\", PrimitiveProcedure(scheme_apply, True))\\\\\\\\n    env.define(\\\\\\\"load\\\\\\\", PrimitiveProcedure(scheme_load, True))\\\\\\\\n    add_primitives(env)\\\\\\\\n    return env\\\\\\\\n\\\\\\\\n@main\\\\\\\\ndef run(*argv):\\\\\\\\n    import argparse\\\\\\\\n    parser = argparse.ArgumentParser(description=\\\\\\\\'CS 61A Scheme interpreter\\\\\\\\')\\\\\\\\n    parser.add_argument(\\\\\\\\'-load\\\\\\\\', \\\\\\\\'-i\\\\\\\\', action=\\\\\\\\'store_true\\\\\\\\',\\\\\\\\n                       help=\\\\\\\\'run file interactively\\\\\\\\')\\\\\\\\n    parser.add_argument(\\\\\\\\'file\\\\\\\\', nargs=\\\\\\\\'?\\\\\\\\',\\\\\\\\n                        type=argparse.FileType(\\\\\\\\'r\\\\\\\\'), default=None,\\\\\\\\n                        help=\\\\\\\\'Scheme file to run\\\\\\\\')\\\\\\\\n    args = parser.parse_args()\\\\\\\\n\\\\\\\\n    next_line = buffer_input\\\\\\\\n    interactive = True\\\\\\\\n    load_files = []\\\\\\\\n\\\\\\\\n    if args.file is not None:\\\\\\\\n        if args.load:\\\\\\\\n            load_files.append(getattr(args.file, \\\\\\\\'name\\\\\\\\'))\\\\\\\\n        else:\\\\\\\\n            lines = args.file.readlines()\\\\\\\\n            def next_line():\\\\\\\\n                return buffer_lines(lines)\\\\\\\\n            interactive = False\\\\\\\\n\\\\\\\\n    read_eval_print_loop(next_line, create_global_frame(), startup=True,\\\\\\\\n                         interactive=interactive, load_files=load_files)\\\\\\\\n    tscheme_exitonclick()\\\\\\\\n', 'tests.scm': ';;; Test cases for Scheme.\\\\\\\\n;;;\\\\\\\\n;;; In order to run only a prefix of these examples, add the line\\\\\\\\n;;;\\\\\\\\n;;; (exit)\\\\\\\\n;;;\\\\\\\\n;;; after the last test you wish to run.\\\\\\\\n\\\\\\\\n;;; **********************************\\\\\\\\n;;; *** Add more of your own here! ***\\\\\\\\n;;; **********************************\\\\\\\\n\\\\\\\\n;;; These are examples from several sections of \\\\\\\"The Structure\\\\\\\\n;;; and Interpretation of Computer Programs\\\\\\\" by Abelson and Sussman.\\\\\\\\n\\\\\\\\n;;; License: Creative Commons share alike with attribution\\\\\\\\n\\\\\\\\n;;; 1.1.1\\\\\\\\n\\\\\\\\n10\\\\\\\\n; expect 10\\\\\\\\n\\\\\\\\n(+ 137 349)\\\\\\\\n; expect 486\\\\\\\\n\\\\\\\\n(- 1000 334)\\\\\\\\n; expect 666\\\\\\\\n\\\\\\\\n(* 5 99)\\\\\\\\n; expect 495\\\\\\\\n\\\\\\\\n(/ 10 5)\\\\\\\\n; expect 2\\\\\\\\n\\\\\\\\n(+ 2.7 10)\\\\\\\\n; expect 12.7\\\\\\\\n\\\\\\\\n(+ 21 35 12 7)\\\\\\\\n; expect 75\\\\\\\\n\\\\\\\\n(* 25 4 12)\\\\\\\\n; expect 1200\\\\\\\\n\\\\\\\\n(+ (* 3 5) (- 10 6))\\\\\\\\n; expect 19\\\\\\\\n\\\\\\\\n(+ (* 3 (+ (* 2 4) (+ 3 5))) (+ (- 10 7) 6))\\\\\\\\n; expect 57\\\\\\\\n\\\\\\\\n(+ (* 3\\\\\\\\n      (+ (* 2 4)\\\\\\\\n         (+ 3 5)))\\\\\\\\n   (+ (- 10 7)\\\\\\\\n      6))\\\\\\\\n; expect 57\\\\\\\\n\\\\\\\\n\\\\\\\\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\\\\\\\\n;;; Move the following (exit) line to run additional tests. ;;;\\\\\\\\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\\\\\\\\n(exit)\\\\\\\\n\\\\\\\\n\\\\\\\\n;;; 1.1.2\\\\\\\\n\\\\\\\\n(define size 2)\\\\\\\\n; expect size\\\\\\\\nsize\\\\\\\\n; expect 2\\\\\\\\n\\\\\\\\n(* 5 size)\\\\\\\\n; expect 10\\\\\\\\n\\\\\\\\n(define pi 3.14159)\\\\\\\\n(define radius 10)\\\\\\\\n(* pi (* radius radius))\\\\\\\\n; expect 314.159\\\\\\\\n\\\\\\\\n(define circumference (* 2 pi radius))\\\\\\\\ncircumference\\\\\\\\n; expect 62.8318\\\\\\\\n\\\\\\\\n;;; 1.1.4\\\\\\\\n\\\\\\\\n(define (square x) (* x x))\\\\\\\\n; expect square\\\\\\\\n(square 21)\\\\\\\\n; expect 441\\\\\\\\n\\\\\\\\n(define square (lambda (x) (* x x))) ; See Section 1.3.2\\\\\\\\n(square 21)\\\\\\\\n; expect 441\\\\\\\\n\\\\\\\\n(square (+ 2 5))\\\\\\\\n; expect 49\\\\\\\\n\\\\\\\\n(square (square 3))\\\\\\\\n; expect 81\\\\\\\\n\\\\\\\\n(define (sum-of-squares x y)\\\\\\\\n  (+ (square x) (square y)))\\\\\\\\n(sum-of-squares 3 4)\\\\\\\\n; expect 25\\\\\\\\n\\\\\\\\n(define (f a)\\\\\\\\n  (sum-of-squares (+ a 1) (* a 2)))\\\\\\\\n(f 5)\\\\\\\\n; expect 136\\\\\\\\n\\\\\\\\n;;; 1.1.6\\\\\\\\n\\\\\\\\n(define (abs x)\\\\\\\\n  (cond ((> x 0) x)\\\\\\\\n        ((= x 0) 0)\\\\\\\\n        ((< x 0) (- x))))\\\\\\\\n(abs -3)\\\\\\\\n; expect 3\\\\\\\\n\\\\\\\\n(abs 0)\\\\\\\\n; expect 0\\\\\\\\n\\\\\\\\n(abs 3)\\\\\\\\n; expect 3\\\\\\\\n\\\\\\\\n(define (a-plus-abs-b a b)\\\\\\\\n  ((if (> b 0) + -) a b))\\\\\\\\n(a-plus-abs-b 3 -2)\\\\\\\\n; expect 5\\\\\\\\n\\\\\\\\n;;; 1.1.7\\\\\\\\n\\\\\\\\n(define (sqrt-iter guess x)\\\\\\\\n  (if (good-enough? guess x)\\\\\\\\n      guess\\\\\\\\n      (sqrt-iter (improve guess x)\\\\\\\\n                 x)))\\\\\\\\n(define (improve guess x)\\\\\\\\n  (average guess (/ x guess)))\\\\\\\\n(define (average x y)\\\\\\\\n  (/ (+ x y) 2))\\\\\\\\n(define (good-enough? guess x)\\\\\\\\n  (< (abs (- (square guess) x)) 0.001))\\\\\\\\n(define (sqrt x)\\\\\\\\n  (sqrt-iter 1.0 x))\\\\\\\\n(sqrt 9)\\\\\\\\n; expect 3.00009155413138\\\\\\\\n\\\\\\\\n(sqrt (+ 100 37))\\\\\\\\n; expect 11.704699917758145\\\\\\\\n\\\\\\\\n(sqrt (+ (sqrt 2) (sqrt 3)))\\\\\\\\n; expect 1.7739279023207892\\\\\\\\n\\\\\\\\n(square (sqrt 1000))\\\\\\\\n; expect 1000.000369924366\\\\\\\\n\\\\\\\\n;;; 1.1.8\\\\\\\\n\\\\\\\\n(define (sqrt x)\\\\\\\\n  (define (good-enough? guess)\\\\\\\\n    (< (abs (- (square guess) x)) 0.001))\\\\\\\\n  (define (improve guess)\\\\\\\\n    (average guess (/ x guess)))\\\\\\\\n  (define (sqrt-iter guess)\\\\\\\\n    (if (good-enough? guess)\\\\\\\\n        guess\\\\\\\\n        (sqrt-iter (improve guess))))\\\\\\\\n  (sqrt-iter 1.0))\\\\\\\\n(sqrt 9)\\\\\\\\n; expect 3.00009155413138\\\\\\\\n\\\\\\\\n(sqrt (+ 100 37))\\\\\\\\n; expect 11.704699917758145\\\\\\\\n\\\\\\\\n(sqrt (+ (sqrt 2) (sqrt 3)))\\\\\\\\n; expect 1.7739279023207892\\\\\\\\n\\\\\\\\n(square (sqrt 1000))\\\\\\\\n; expect 1000.000369924366\\\\\\\\n\\\\\\\\n;;; 1.3.1\\\\\\\\n\\\\\\\\n(define (cube x) (* x x x))\\\\\\\\n(define (sum term a next b)\\\\\\\\n  (if (> a b)\\\\\\\\n      0\\\\\\\\n      (+ (term a)\\\\\\\\n         (sum term (next a) next b))))\\\\\\\\n(define (inc n) (+ n 1))\\\\\\\\n(define (sum-cubes a b)\\\\\\\\n  (sum cube a inc b))\\\\\\\\n(sum-cubes 1 10)\\\\\\\\n; expect 3025\\\\\\\\n\\\\\\\\n(define (identity x) x)\\\\\\\\n(define (sum-integers a b)\\\\\\\\n  (sum identity a inc b))\\\\\\\\n(sum-integers 1 10)\\\\\\\\n; expect 55\\\\\\\\n\\\\\\\\n;;; 1.3.2\\\\\\\\n\\\\\\\\n((lambda (x y z) (+ x y (square z))) 1 2 3)\\\\\\\\n; expect 12\\\\\\\\n\\\\\\\\n(define (f x y)\\\\\\\\n  (let ((a (+ 1 (* x y)))\\\\\\\\n        (b (- 1 y)))\\\\\\\\n    (+ (* x (square a))\\\\\\\\n       (* y b)\\\\\\\\n       (* a b))))\\\\\\\\n(f 3 4)\\\\\\\\n; expect 456\\\\\\\\n\\\\\\\\n(define x 5)\\\\\\\\n(+ (let ((x 3))\\\\\\\\n     (+ x (* x 10)))\\\\\\\\n   x)\\\\\\\\n; expect 38\\\\\\\\n\\\\\\\\n(let ((x 3)\\\\\\\\n      (y (+ x 2)))\\\\\\\\n  (* x y))\\\\\\\\n; expect 21\\\\\\\\n\\\\\\\\n;;; 2.1.1\\\\\\\\n\\\\\\\\n(define (add-rat x y)\\\\\\\\n  (make-rat (+ (* (numer x) (denom y))\\\\\\\\n               (* (numer y) (denom x)))\\\\\\\\n            (* (denom x) (denom y))))\\\\\\\\n(define (sub-rat x y)\\\\\\\\n  (make-rat (- (* (numer x) (denom y))\\\\\\\\n               (* (numer y) (denom x)))\\\\\\\\n            (* (denom x) (denom y))))\\\\\\\\n(define (mul-rat x y)\\\\\\\\n  (make-rat (* (numer x) (numer y))\\\\\\\\n            (* (denom x) (denom y))))\\\\\\\\n(define (div-rat x y)\\\\\\\\n  (make-rat (* (numer x) (denom y))\\\\\\\\n            (* (denom x) (numer y))))\\\\\\\\n(define (equal-rat? x y)\\\\\\\\n  (= (* (numer x) (denom y))\\\\\\\\n     (* (numer y) (denom x))))\\\\\\\\n\\\\\\\\n(define x (cons 1 2))\\\\\\\\n(car x)\\\\\\\\n; expect 1\\\\\\\\n\\\\\\\\n(cdr x)\\\\\\\\n; expect 2\\\\\\\\n\\\\\\\\n(define x (cons 1 2))\\\\\\\\n(define y (cons 3 4))\\\\\\\\n(define z (cons x y))\\\\\\\\n(car (car z))\\\\\\\\n; expect 1\\\\\\\\n\\\\\\\\n(car (cdr z))\\\\\\\\n; expect 3\\\\\\\\n\\\\\\\\nz\\\\\\\\n; expect ((1 . 2) 3 . 4)\\\\\\\\n\\\\\\\\n(define (make-rat n d) (cons n d))\\\\\\\\n(define (numer x) (car x))\\\\\\\\n(define (denom x) (cdr x))\\\\\\\\n(define (print-rat x)\\\\\\\\n  (display (numer x))\\\\\\\\n  (display \\\\\\\\'/)\\\\\\\\n  (display (denom x))\\\\\\\\n  (newline))\\\\\\\\n(define one-half (make-rat 1 2))\\\\\\\\n(print-rat one-half)\\\\\\\\n; expect 1/2 ; okay\\\\\\\\n\\\\\\\\n(define one-third (make-rat 1 3))\\\\\\\\n(print-rat (add-rat one-half one-third))\\\\\\\\n; expect 5/6 ; okay\\\\\\\\n\\\\\\\\n(print-rat (mul-rat one-half one-third))\\\\\\\\n; expect 1/6 ; okay\\\\\\\\n\\\\\\\\n(print-rat (add-rat one-third one-third))\\\\\\\\n; expect 6/9 ; okay\\\\\\\\n\\\\\\\\n(define (gcd a b)\\\\\\\\n  (if (= b 0)\\\\\\\\n      a\\\\\\\\n      (gcd b (remainder a b))))\\\\\\\\n(define (make-rat n d)\\\\\\\\n  (let ((g (gcd n d)))\\\\\\\\n    (cons (/ n g) (/ d g))))\\\\\\\\n(print-rat (add-rat one-third one-third))\\\\\\\\n; expect 2/3 ; okay\\\\\\\\n\\\\\\\\n(define one-through-four (list 1 2 3 4))\\\\\\\\none-through-four\\\\\\\\n; expect (1 2 3 4)\\\\\\\\n\\\\\\\\n(car one-through-four)\\\\\\\\n; expect 1\\\\\\\\n\\\\\\\\n(cdr one-through-four)\\\\\\\\n; expect (2 3 4)\\\\\\\\n\\\\\\\\n(car (cdr one-through-four))\\\\\\\\n; expect 2\\\\\\\\n\\\\\\\\n(cons 10 one-through-four)\\\\\\\\n; expect (10 1 2 3 4)\\\\\\\\n\\\\\\\\n(cons 5 one-through-four)\\\\\\\\n; expect (5 1 2 3 4)\\\\\\\\n\\\\\\\\n(define (map proc items)\\\\\\\\n  (if (null? items)\\\\\\\\n      nil\\\\\\\\n      (cons (proc (car items))\\\\\\\\n            (map proc (cdr items)))))\\\\\\\\n(map abs (list -10 2.5 -11.6 17))\\\\\\\\n; expect (10 2.5 11.6 17)\\\\\\\\n\\\\\\\\n(map (lambda (x) (* x x))\\\\\\\\n     (list 1 2 3 4))\\\\\\\\n; expect (1 4 9 16)\\\\\\\\n\\\\\\\\n(define (scale-list items factor)\\\\\\\\n  (map (lambda (x) (* x factor))\\\\\\\\n       items))\\\\\\\\n(scale-list (list 1 2 3 4 5) 10)\\\\\\\\n; expect (10 20 30 40 50)\\\\\\\\n\\\\\\\\n(define (count-leaves x)\\\\\\\\n  (cond ((null? x) 0)\\\\\\\\n        ((not (pair? x)) 1)\\\\\\\\n        (else (+ (count-leaves (car x))\\\\\\\\n                 (count-leaves (cdr x))))))\\\\\\\\n(define x (cons (list 1 2) (list 3 4)))\\\\\\\\n(count-leaves x)\\\\\\\\n; expect 4\\\\\\\\n\\\\\\\\n(count-leaves (list x x))\\\\\\\\n; expect 8\\\\\\\\n\\\\\\\\n;;; 2.2.3\\\\\\\\n\\\\\\\\n(define (odd? x) (= 1 (remainder x 2)))\\\\\\\\n(define (filter predicate sequence)\\\\\\\\n  (cond ((null? sequence) nil)\\\\\\\\n        ((predicate (car sequence))\\\\\\\\n         (cons (car sequence)\\\\\\\\n               (filter predicate (cdr sequence))))\\\\\\\\n        (else (filter predicate (cdr sequence)))))\\\\\\\\n(filter odd? (list 1 2 3 4 5))\\\\\\\\n; expect (1 3 5)\\\\\\\\n\\\\\\\\n(define (accumulate op initial sequence)\\\\\\\\n  (if (null? sequence)\\\\\\\\n      initial\\\\\\\\n      (op (car sequence)\\\\\\\\n          (accumulate op initial (cdr sequence)))))\\\\\\\\n(accumulate + 0 (list 1 2 3 4 5))\\\\\\\\n; expect 15\\\\\\\\n\\\\\\\\n(accumulate * 1 (list 1 2 3 4 5))\\\\\\\\n; expect 120\\\\\\\\n\\\\\\\\n(accumulate cons nil (list 1 2 3 4 5))\\\\\\\\n; expect (1 2 3 4 5)\\\\\\\\n\\\\\\\\n(define (enumerate-interval low high)\\\\\\\\n  (if (> low high)\\\\\\\\n      nil\\\\\\\\n      (cons low (enumerate-interval (+ low 1) high))))\\\\\\\\n(enumerate-interval 2 7)\\\\\\\\n; expect (2 3 4 5 6 7)\\\\\\\\n\\\\\\\\n(define (enumerate-tree tree)\\\\\\\\n  (cond ((null? tree) nil)\\\\\\\\n        ((not (pair? tree)) (list tree))\\\\\\\\n        (else (append (enumerate-tree (car tree))\\\\\\\\n                      (enumerate-tree (cdr tree))))))\\\\\\\\n(enumerate-tree (list 1 (list 2 (list 3 4)) 5))\\\\\\\\n; expect (1 2 3 4 5)\\\\\\\\n\\\\\\\\n;;; 2.3.1\\\\\\\\n\\\\\\\\n(define a 1)\\\\\\\\n\\\\\\\\n(define b 2)\\\\\\\\n\\\\\\\\n(list a b)\\\\\\\\n; expect (1 2)\\\\\\\\n\\\\\\\\n(list \\\\\\\\'a \\\\\\\\'b)\\\\\\\\n; expect (a b)\\\\\\\\n\\\\\\\\n(list \\\\\\\\'a b)\\\\\\\\n; expect (a 2)\\\\\\\\n\\\\\\\\n(car \\\\\\\\'(a b c))\\\\\\\\n; expect a\\\\\\\\n\\\\\\\\n(cdr \\\\\\\\'(a b c))\\\\\\\\n; expect (b c)\\\\\\\\n\\\\\\\\n(define (memq item x)\\\\\\\\n  (cond ((null? x) false)\\\\\\\\n        ((eq? item (car x)) x)\\\\\\\\n        (else (memq item (cdr x)))))\\\\\\\\n(memq \\\\\\\\'apple \\\\\\\\'(pear banana prune))\\\\\\\\n; expect False\\\\\\\\n\\\\\\\\n(memq \\\\\\\\'apple \\\\\\\\'(x (apple sauce) y apple pear))\\\\\\\\n; expect (apple pear)\\\\\\\\n\\\\\\\\n(define (equal? x y)\\\\\\\\n  (cond ((pair? x) (and (pair? y)\\\\\\\\n                        (equal? (car x) (car y))\\\\\\\\n                        (equal? (cdr x) (cdr y))))\\\\\\\\n        ((null? x) (null? y))\\\\\\\\n        (else (eq? x y))))\\\\\\\\n(equal? \\\\\\\\'(1 2 (three)) \\\\\\\\'(1 2 (three)))\\\\\\\\n; expect True\\\\\\\\n\\\\\\\\n(equal? \\\\\\\\'(1 2 (three)) \\\\\\\\'(1 2 three))\\\\\\\\n; expect False\\\\\\\\n\\\\\\\\n(equal? \\\\\\\\'(1 2 three) \\\\\\\\'(1 2 (three)))\\\\\\\\n; expect False\\\\\\\\n\\\\\\\\n;;; Peter Norvig tests (http://norvig.com/lispy2.html)\\\\\\\\n\\\\\\\\n(define double (lambda (x) (* 2 x)))\\\\\\\\n(double 5)\\\\\\\\n; expect 10\\\\\\\\n\\\\\\\\n(define compose (lambda (f g) (lambda (x) (f (g x)))))\\\\\\\\n((compose list double) 5)\\\\\\\\n; expect (10)\\\\\\\\n\\\\\\\\n(define apply-twice (lambda (f) (compose f f)))\\\\\\\\n((apply-twice double) 5)\\\\\\\\n; expect 20\\\\\\\\n\\\\\\\\n((apply-twice (apply-twice double)) 5)\\\\\\\\n; expect 80\\\\\\\\n\\\\\\\\n(define fact (lambda (n) (if (<= n 1) 1 (* n (fact (- n 1))))))\\\\\\\\n(fact 3)\\\\\\\\n; expect 6\\\\\\\\n\\\\\\\\n(fact 50)\\\\\\\\n; expect 30414093201713378043612608166064768844377641568960512000000000000\\\\\\\\n\\\\\\\\n(define (combine f)\\\\\\\\n  (lambda (x y)\\\\\\\\n    (if (null? x) nil\\\\\\\\n      (f (list (car x) (car y))\\\\\\\\n         ((combine f) (cdr x) (cdr y))))))\\\\\\\\n(define zip (combine cons))\\\\\\\\n(zip (list 1 2 3 4) (list 5 6 7 8))\\\\\\\\n; expect ((1 5) (2 6) (3 7) (4 8))\\\\\\\\n\\\\\\\\n(define riff-shuffle (lambda (deck) (begin\\\\\\\\n    (define take (lambda (n seq) (if (<= n 0) (quote ()) (cons (car seq) (take (- n 1) (cdr seq))))))\\\\\\\\n    (define drop (lambda (n seq) (if (<= n 0) seq (drop (- n 1) (cdr seq)))))\\\\\\\\n    (define mid (lambda (seq) (/ (length seq) 2)))\\\\\\\\n    ((combine append) (take (mid deck) deck) (drop (mid deck) deck)))))\\\\\\\\n(riff-shuffle (list 1 2 3 4 5 6 7 8))\\\\\\\\n; expect (1 5 2 6 3 7 4 8)\\\\\\\\n\\\\\\\\n((apply-twice riff-shuffle) (list 1 2 3 4 5 6 7 8))\\\\\\\\n; expect (1 3 5 7 2 4 6 8)\\\\\\\\n\\\\\\\\n(riff-shuffle (riff-shuffle (riff-shuffle (list 1 2 3 4 5 6 7 8))))\\\\\\\\n; expect (1 2 3 4 5 6 7 8)\\\\\\\\n\\\\\\\\n;;; Additional tests\\\\\\\\n\\\\\\\\n(apply square \\\\\\\\'(2))\\\\\\\\n; expect 4\\\\\\\\n\\\\\\\\n(apply + \\\\\\\\'(1 2 3 4))\\\\\\\\n; expect 10\\\\\\\\n\\\\\\\\n(apply (if false + append) \\\\\\\\'((1 2) (3 4)))\\\\\\\\n; expect (1 2 3 4)\\\\\\\\n\\\\\\\\n(if 0 1 2)\\\\\\\\n; expect 1\\\\\\\\n\\\\\\\\n(if \\\\\\\\'() 1 2)\\\\\\\\n; expect 1\\\\\\\\n\\\\\\\\n(or false true)\\\\\\\\n; expect True\\\\\\\\n\\\\\\\\n(or)\\\\\\\\n; expect False\\\\\\\\n\\\\\\\\n(and)\\\\\\\\n; expect True\\\\\\\\n\\\\\\\\n(or 1 2 3)\\\\\\\\n; expect 1\\\\\\\\n\\\\\\\\n(and 1 2 3)\\\\\\\\n; expect 3\\\\\\\\n\\\\\\\\n(and False (/ 1 0))\\\\\\\\n; expect False\\\\\\\\n\\\\\\\\n(and True (/ 1 0))\\\\\\\\n; expect Error\\\\\\\\n\\\\\\\\n(or 3 (/ 1 0))\\\\\\\\n; expect 3\\\\\\\\n\\\\\\\\n(or False (/ 1 0))\\\\\\\\n; expect Error\\\\\\\\n\\\\\\\\n(or (quote hello) (quote world))\\\\\\\\n; expect hello\\\\\\\\n\\\\\\\\n(if nil 1 2)\\\\\\\\n; expect 1\\\\\\\\n\\\\\\\\n(if 0 1 2)\\\\\\\\n; expect 1\\\\\\\\n\\\\\\\\n(if (or false False #f) 1 2)\\\\\\\\n; expect 2\\\\\\\\n\\\\\\\\n(define (loop) (loop))\\\\\\\\n(cond (false (loop))\\\\\\\\n      (12))\\\\\\\\n; expect 12\\\\\\\\n\\\\\\\\n((lambda (x) (display x) (newline) x) 2)\\\\\\\\n; expect 2 ; 2\\\\\\\\n\\\\\\\\n(define g (mu () x))\\\\\\\\n(define (high f x)\\\\\\\\n  (f))\\\\\\\\n\\\\\\\\n(high g 2)\\\\\\\\n; expect 2\\\\\\\\n\\\\\\\\n(define (print-and-square x)\\\\\\\\n  (print x)\\\\\\\\n  (square x))\\\\\\\\n(print-and-square 12)\\\\\\\\n; expect 12 ; 144\\\\\\\\n\\\\\\\\n(/ 1 0)\\\\\\\\n; expect Error\\\\\\\\n\\\\\\\\n(define addx (mu (x) (+ x y)))\\\\\\\\n(define add2xy (lambda (x y) (addx (+ x x))))\\\\\\\\n(add2xy 3 7)\\\\\\\\n; expect 13\\\\\\\\n\\\\\\\\n\\\\\\\\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\\\\\\\\n;;; Scheme Implementations ;;;\\\\\\\\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\\\\\\\\n\\\\\\\\n;; len outputs the length of list s\\\\\\\\n(define (len s)\\\\\\\\n  (if (eq? s \\\\\\\\'())\\\\\\\\n    0\\\\\\\\n    (+ 1 (len (cdr s)))))\\\\\\\\n(len \\\\\\\\'(1 2 3 4))\\\\\\\\n; expect 4\\\\\\\\n\\\\\\\\n\\\\\\\\n;;;;;;;;;;;;;;;;;;;;\\\\\\\\n;;; Extra credit ;;;\\\\\\\\n;;;;;;;;;;;;;;;;;;;;\\\\\\\\n\\\\\\\\n(exit)\\\\\\\\n\\\\\\\\n; Tail call optimization tests\\\\\\\\n\\\\\\\\n(define (sum n total)\\\\\\\\n  (if (zero? n) total\\\\\\\\n    (sum (- n 1) (+ n total))))\\\\\\\\n(sum 1001 0)\\\\\\\\n; expect 501501\\\\\\\\n\\\\\\\\n(define (sum n total)\\\\\\\\n  (cond ((zero? n) total)\\\\\\\\n        (else (sum (- n 1) (+ n total)))))\\\\\\\\n(sum 1001 0)\\\\\\\\n; expect 501501\\\\\\\\n\\\\\\\\n(define (sum n total)\\\\\\\\n  (begin 2 3\\\\\\\\n    (if (zero? n) total\\\\\\\\n      (and 2 3\\\\\\\\n        (or false\\\\\\\\n          (begin 2 3\\\\\\\\n            (let ((m n))\\\\\\\\n              (sum (- m 1) (+ m total)))))))))\\\\\\\\n(sum 1001 0)\\\\\\\\n; expect 501501\\\\\\\\n\\\\\\\\n', 'scheme_reader.py': '\\\\\\\"\\\\\\\"\\\\\\\"This module implements the built-in data types of the Scheme language, along\\\\\\\\nwith a parser for Scheme expressions.\\\\\\\\n\\\\\\\\nIn addition to the types defined in this file, some data types in Scheme are\\\\\\\\nrepresented by their corresponding type in Python:\\\\\\\\n    number:       int or float\\\\\\\\n    symbol:       string\\\\\\\\n    boolean:      bool\\\\\\\\n    unspecified:  None\\\\\\\\n\\\\\\\\nThe __repr__ method of a Scheme value will return a Python expression that\\\\\\\\nwould be evaluated to the value, where possible.\\\\\\\\n\\\\\\\\nThe __str__ method of a Scheme value will return a Scheme expression that\\\\\\\\nwould be read to the value, where possible.\\\\\\\\n\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\\n\\\\\\\\nfrom ucb import main, trace, interact\\\\\\\\nfrom scheme_tokens import tokenize_lines, DELIMITERS\\\\\\\\nfrom buffer import Buffer, InputReader, LineReader\\\\\\\\n\\\\\\\\n# Pairs and Scheme lists\\\\\\\\n\\\\\\\\nclass Pair:\\\\\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"A pair has two instance attributes: first and second.  For a Pair to be\\\\\\\\n    a well-formed list, second is either a well-formed list or nil.  Some\\\\\\\\n    methods only apply to well-formed lists.\\\\\\\\n\\\\\\\\n    >>> s = Pair(1, Pair(2, nil))\\\\\\\\n    >>> s\\\\\\\\n    Pair(1, Pair(2, nil))\\\\\\\\n    >>> print(s)\\\\\\\\n    (1 2)\\\\\\\\n    >>> print(s.map(lambda x: x+4))\\\\\\\\n    (5 6)\\\\\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\\n    def __init__(self, first, second):\\\\\\\\n        self.first = first\\\\\\\\n        self.second = second\\\\\\\\n\\\\\\\\n    def __repr__(self):\\\\\\\\n        return \\\\\\\"Pair({0}, {1})\\\\\\\".format(repr(self.first), repr(self.second))\\\\\\\\n\\\\\\\\n    def __str__(self):\\\\\\\\n        s = \\\\\\\"(\\\\\\\" + str(self.first)\\\\\\\\n        second = self.second\\\\\\\\n        while isinstance(second, Pair):\\\\\\\\n            s += \\\\\\\" \\\\\\\" + str(second.first)\\\\\\\\n            second = second.second\\\\\\\\n        if second is not nil:\\\\\\\\n            s += \\\\\\\" . \\\\\\\" + str(second)\\\\\\\\n        return s + \\\\\\\")\\\\\\\"\\\\\\\\n\\\\\\\\n    def __len__(self):\\\\\\\\n        n, second = 1, self.second\\\\\\\\n        while isinstance(second, Pair):\\\\\\\\n            n += 1\\\\\\\\n            second = second.second\\\\\\\\n        if second is not nil:\\\\\\\\n            raise TypeError(\\\\\\\"length attempted on improper list\\\\\\\")\\\\\\\\n        return n\\\\\\\\n\\\\\\\\n    def __eq__(self, p):\\\\\\\\n        if not isinstance(p, Pair):\\\\\\\\n            return False\\\\\\\\n        return self.first == p.first and self.second == p.second\\\\\\\\n\\\\\\\\n    def map(self, fn):\\\\\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"Return a Scheme list after mapping Python function FN to SELF.\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\\n        mapped = fn(self.first)\\\\\\\\n        if self.second is nil or isinstance(self.second, Pair):\\\\\\\\n            return Pair(mapped, self.second.map(fn))\\\\\\\\n        else:\\\\\\\\n            raise TypeError(\\\\\\\"ill-formed list\\\\\\\")\\\\\\\\n\\\\\\\\nclass nil:\\\\\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"The empty list\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\\n\\\\\\\\n    def __repr__(self):\\\\\\\\n        return \\\\\\\"nil\\\\\\\"\\\\\\\\n\\\\\\\\n    def __str__(self):\\\\\\\\n        return \\\\\\\"()\\\\\\\"\\\\\\\\n\\\\\\\\n    def __len__(self):\\\\\\\\n        return 0\\\\\\\\n\\\\\\\\n    def map(self, fn):\\\\\\\\n        return self\\\\\\\\n\\\\\\\\nnil = nil() # Assignment hides the nil class; there is only one instance\\\\\\\\n\\\\\\\\n# Scheme list parser\\\\\\\\n\\\\\\\\n\\\\\\\\ndef scheme_read(src):\\\\\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"Read the next expression from SRC, a Buffer of tokens.\\\\\\\\n\\\\\\\\n    >>> lines = [\\\\\\\"(+ 1 \\\\\\\", \\\\\\\"(+ 23 4)) (\\\\\\\"]\\\\\\\\n    >>> src = Buffer(tokenize_lines(lines))\\\\\\\\n    >>> print(scheme_read(src))\\\\\\\\n    (+ 1 (+ 23 4))\\\\\\\\n    >>> read_line(\\\\\\\"\\\\\\\\'hello\\\\\\\")\\\\\\\\n    Pair(\\\\\\\\'quote\\\\\\\\', Pair(\\\\\\\\'hello\\\\\\\\', nil))\\\\\\\\n    >>> print(read_line(\\\\\\\"(car \\\\\\\\'(1 2))\\\\\\\"))\\\\\\\\n    (car (quote (1 2)))\\\\\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\\n    if src.current() is None:\\\\\\\\n        raise EOFError\\\\\\\\n    val = src.pop()\\\\\\\\n    if val == \\\\\\\"nil\\\\\\\":\\\\\\\\n        return nil\\\\\\\\n    elif val not in DELIMITERS:\\\\\\\\n        return val\\\\\\\\n    elif val == \\\\\\\"\\\\\\\\'\\\\\\\":\\\\\\\\n        # BEGIN Question 1\\\\\\\\n        \\\\\\\"*** REPLACE THIS LINE ***\\\\\\\"\\\\\\\\n        # END Question 1\\\\\\\\n    elif val == \\\\\\\"(\\\\\\\":\\\\\\\\n        return read_tail(src)\\\\\\\\n    else:\\\\\\\\n        raise SyntaxError(\\\\\\\"unexpected token: {0}\\\\\\\".format(val))\\\\\\\\n\\\\\\\\ndef read_tail(src):\\\\\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"Return the remainder of a list in SRC, starting before an element or ).\\\\\\\\n\\\\\\\\n    >>> read_tail(Buffer(tokenize_lines([\\\\\\\")\\\\\\\"])))\\\\\\\\n    nil\\\\\\\\n    >>> read_tail(Buffer(tokenize_lines([\\\\\\\"2 3)\\\\\\\"])))\\\\\\\\n    Pair(2, Pair(3, nil))\\\\\\\\n    >>> read_tail(Buffer(tokenize_lines([\\\\\\\"2 (3 4))\\\\\\\"])))\\\\\\\\n    Pair(2, Pair(Pair(3, Pair(4, nil)), nil))\\\\\\\\n    >>> read_line(\\\\\\\"(1 . 2)\\\\\\\")\\\\\\\\n    Pair(1, 2)\\\\\\\\n    >>> read_line(\\\\\\\"(1 2 . 3)\\\\\\\")\\\\\\\\n    Pair(1, Pair(2, 3))\\\\\\\\n    >>> read_line(\\\\\\\"(1 . 2 3)\\\\\\\")\\\\\\\\n    Traceback (most recent call last):\\\\\\\\n      ...\\\\\\\\n    SyntaxError: expected one element after .\\\\\\\\n    >>> scheme_read(Buffer(tokenize_lines([\\\\\\\"(1\\\\\\\", \\\\\\\"2 .\\\\\\\", \\\\\\\"\\\\\\\\'(3 4))\\\\\\\", \\\\\\\"4\\\\\\\"])))\\\\\\\\n    Pair(1, Pair(2, Pair(\\\\\\\\'quote\\\\\\\\', Pair(Pair(3, Pair(4, nil)), nil))))\\\\\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\\n    try:\\\\\\\\n        if src.current() is None:\\\\\\\\n            raise SyntaxError(\\\\\\\"unexpected end of file\\\\\\\")\\\\\\\\n        elif src.current() == \\\\\\\")\\\\\\\":\\\\\\\\n            src.pop()\\\\\\\\n            return nil\\\\\\\\n        elif src.current() == \\\\\\\".\\\\\\\":\\\\\\\\n            # BEGIN Question 2\\\\\\\\n            \\\\\\\"*** REPLACE THIS LINE ***\\\\\\\"\\\\\\\\n            # END Question 2\\\\\\\\n        else:\\\\\\\\n            first = scheme_read(src)\\\\\\\\n            rest = read_tail(src)\\\\\\\\n            return Pair(first, rest)\\\\\\\\n    except EOFError:\\\\\\\\n        raise SyntaxError(\\\\\\\"unexpected end of file\\\\\\\")\\\\\\\\n\\\\\\\\n# Convenience methods\\\\\\\\n\\\\\\\\ndef buffer_input(prompt=\\\\\\\"scm> \\\\\\\"):\\\\\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"Return a Buffer instance containing interactive input.\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\\n    return Buffer(tokenize_lines(InputReader(prompt)))\\\\\\\\n\\\\\\\\ndef buffer_lines(lines, prompt=\\\\\\\"scm> \\\\\\\", show_prompt=False):\\\\\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"Return a Buffer instance iterating through LINES.\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\\n    if show_prompt:\\\\\\\\n        input_lines = lines\\\\\\\\n    else:\\\\\\\\n        input_lines = LineReader(lines, prompt)\\\\\\\\n    return Buffer(tokenize_lines(input_lines))\\\\\\\\n\\\\\\\\ndef read_line(line):\\\\\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"Read a single string LINE as a Scheme expression.\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\\n    return scheme_read(Buffer(tokenize_lines([line])))\\\\\\\\n\\\\\\\\n# Interactive loop\\\\\\\\n\\\\\\\\n@main\\\\\\\\ndef read_print_loop():\\\\\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"Run a read-print loop for Scheme expressions.\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\\n    while True:\\\\\\\\n        try:\\\\\\\\n            src = buffer_input(\\\\\\\"read> \\\\\\\")\\\\\\\\n            while src.more_on_line:\\\\\\\\n                expression = scheme_read(src)\\\\\\\\n                print(\\\\\\\"str :\\\\\\\", expression)\\\\\\\\n                print(\\\\\\\"repr:\\\\\\\", repr(expression))\\\\\\\\n        except (SyntaxError, ValueError) as err:\\\\\\\\n            print(type(err).__name__ + \\\\\\\":\\\\\\\", err)\\\\\\\\n        except (KeyboardInterrupt, EOFError):  # <Control>-D, etc.\\\\\\\\n            print()\\\\\\\\n            return\\\\\\\\n', 'questions.scm': \\\\\\\"(define (caar x) (car (car x)))\\\\\\\\n(define (cadr x) (car (cdr x)))\\\\\\\\n(define (cddr x) (cdr (cdr x)))\\\\\\\\n(define (cadar x) (car (cdr (car x))))\\\\\\\\n\\\\\\\\n; Some utility functions that you may find useful to implement.\\\\\\\\n(define (map proc items)\\\\\\\\n  'REPLACE-THIS-LINE)\\\\\\\\n\\\\\\\\n(define (cons-all first rests)\\\\\\\\n  'REPLACE-THIS-LINE)\\\\\\\\n\\\\\\\\n(define (zip pairs)\\\\\\\\n  'REPLACE-THIS-LINE)\\\\\\\\n\\\\\\\\n;; Problem 18\\\\\\\\n;; Returns a list of two-element lists\\\\\\\\n(define (enumerate s)\\\\\\\\n  ; BEGIN Question 18\\\\\\\\n  'REPLACE-THIS-LINE\\\\\\\\n  )\\\\\\\\n  ; END Question 18\\\\\\\\n\\\\\\\\n;; Problem 19\\\\\\\\n;; List all ways to make change for TOTAL with DENOMS\\\\\\\\n(define (list-change total denoms)\\\\\\\\n  ; BEGIN Question 19\\\\\\\\n  'REPLACE-THIS-LINE\\\\\\\\n  )\\\\\\\\n  ; END Question 19\\\\\\\\n\\\\\\\\n;; Problem 20\\\\\\\\n;; Returns a function that checks if an expression is the special form FORM\\\\\\\\n(define (check-special form)\\\\\\\\n  (lambda (expr) (equal? form (car expr))))\\\\\\\\n\\\\\\\\n(define lambda? (check-special 'lambda))\\\\\\\\n(define define? (check-special 'define))\\\\\\\\n(define quoted? (check-special 'quote))\\\\\\\\n(define let?    (check-special 'let))\\\\\\\\n\\\\\\\\n;; Converts all let special forms in EXPR into equivalent forms using lambda\\\\\\\\n(define (analyze expr)\\\\\\\\n  (cond ((atom? expr)\\\\\\\\n         ; BEGIN Question 20\\\\\\\\n         'REPLACE-THIS-LINE\\\\\\\\n         ; END Question 20\\\\\\\\n         )\\\\\\\\n        ((quoted? expr)\\\\\\\\n         ; BEGIN Question 20\\\\\\\\n         'REPLACE-THIS-LINE\\\\\\\\n         ; END Question 20\\\\\\\\n         )\\\\\\\\n        ((or (lambda? expr)\\\\\\\\n             (define? expr))\\\\\\\\n         (let ((form   (car expr))\\\\\\\\n               (params (cadr expr))\\\\\\\\n               (body   (cddr expr)))\\\\\\\\n           ; BEGIN Question 20\\\\\\\\n           'REPLACE-THIS-LINE\\\\\\\\n           ; END Question 20\\\\\\\\n           ))\\\\\\\\n        ((let? expr)\\\\\\\\n         (let ((values (cadr expr))\\\\\\\\n               (body   (cddr expr)))\\\\\\\\n           ; BEGIN Question 20\\\\\\\\n           'REPLACE-THIS-LINE\\\\\\\\n           ; END Question 20\\\\\\\\n           ))\\\\\\\\n        (else\\\\\\\\n         ; BEGIN Question 20\\\\\\\\n         'REPLACE-THIS-LINE\\\\\\\\n         ; END Question 20\\\\\\\\n         )))\\\\\\\\n\\\\\\\\n;; Problem 21 (optional)\\\\\\\\n;; Draw the hax image using turtle graphics.\\\\\\\\n(define (hax d k)\\\\\\\\n  ; BEGIN Question 21\\\\\\\\n  'REPLACE-THIS-LINE\\\\\\\\n  )\\\\\\\\n  ; END Question 21\\\\\\\\n\\\\\\\\n\\\\\\\"}\\\"\",\n        \"url\": null\n    },\n    \"created\": \"2015-11-07 17:45:36.969350\",\n    \"id\": 6052407744135168,\n    \"invited\": [],\n    \"member\": [\n        {\n            \"created\": \"2015-08-26 00:06:29.273670\",\n            \"email\": [\n                \"bowenwang@berkeley.edu\"\n            ],\n            \"id\": 6148998238830592,\n            \"is_admin\": false\n        },\n        {\n            \"created\": \"2015-08-26 00:06:49.546480\",\n            \"email\": [\n                \"t.h.wang@berkeley.edu\"\n            ],\n            \"id\": 5353786117718016,\n            \"is_admin\": false\n        }\n    ],\n    \"order\": null\n}",
            "questions.scm": "(define (caar x) (car (car x)))\n(define (cadr x) (car (cdr x)))\n(define (cddr x) (cdr (cdr x)))\n(define (cadar x) (car (cdr (car x))))\n(define (caadr x) (car (car (cdr x))))\n(define (cadadr x) (car(cdr (car (cdr x)))))\n\n; Some utility functions that you may find useful to implement.\n(define (map proc items)\n  (if (null? items)\n      nil\n      (cons (proc (car items))\n            (map proc (cdr items)))))\n\n(define (cons-all first rests)\n  (cond\n    ;((null? rests) (cons first nil))\n    ((null? rests) nil)\n    (else (cons (cons first (car rests)) (cons-all first (cdr rests))))\n  )\n)\n\n(define (zip pairs)\n  (cond\n  ((null? pairs) ())\n  (else (cons (firstzip pairs) (zip (zip_helper pairs))))\n  )\n  )\n\n(define (firstzip pairs)\n  (cond\n    ((null? pairs) nil)\n    (else (cons (car (car pairs)) (firstzip (cdr pairs))))\n  )\n  )\n\n(define (zip_helper pairs)\n  (cond\n  ((null? pairs) nil)\n  ((null? (cdr (car pairs))) nil)\n  (else (cons (cdr (car pairs)) (zip_helper (cdr pairs))))\n  )\n  )\n\n\n\n;; Problem 18\n;; Returns a list of two-element lists\n(define (enumerate s)\n  ; BEGIN Question 18\n  (enum_helper s 0)\n  )\n\n(define (enum_helper s num)\n  (cond\n  ((equal? nil s) ())\n  (else (cons (cons num (cons (car s) nil)) (enum_helper (cdr s) (+ num 1))))\n  )\n  )\n  ; END Question 18\n  \n;; Problem 19\n;; List all ways to make change for TOTAL with DENOMS\n(define (list-change total denoms)\n  ; BEGIN Question 19\n  (cond\n    ((null? denoms) ())\n    ;((equal? 0 total) ())\n    (\n    (>= total (car denoms))\n      (append\n        (cond\n        ((null? (list-change (- total (car denoms)) denoms)) (cons (cons (car denoms) nil) nil))\n        (else (cons-all (car denoms) (list-change (- total (car denoms)) denoms)))\n          )\n        (list-change total (cdr denoms))\n      )\n    )\n    (else\n      (list-change total (cdr denoms))\n    )\n  )\n)\n  ; END Question 19\n\n(define (sum elemList)\n  (if\n    (null? elemList)\n    0\n    (+ (car elemList) (sum (cdr elemList)))\n  )\n)\n\n\n;; Problem 20\n;; Returns a function that checks if an expression is the special form FORM\n(define (check-special form)\n  (lambda (expr) (equal? form (car expr))))\n\n(define lambda? (check-special 'lambda))\n(define define? (check-special 'define))\n(define quoted? (check-special 'quote))\n(define let?    (check-special 'let))\n\n;; Converts all let special forms in EXPR into equivalent forms using lambda\n(define (analyze expr)\n  (cond ((atom? expr)\n         ; BEGIN Question 20\n         expr\n         ; END Question 20\n         )\n        ((quoted? expr)\n         ; BEGIN Question 20\n         expr\n         ; END Question 20\n         )\n        ((or (lambda? expr)\n             (define? expr))\n         (let ((form   (car expr))\n               (params (cadr expr))\n               (body   (cddr expr)))\n           ; BEGIN Question 20\n          (cons form (cons params (analyze body)))\n           ; END Question 20\n           ))\n        ((let? expr)\n         (let ((values (cadr expr))\n               (body   (cddr expr)))\n           ; BEGIN Question 20\n           (define param (zip values))\n\n           (define args (car param))\n           (define func (car body))\n           (define vals (cadr param))\n           (define f (analyze func))\n           (cons (lambda args f) (map analyze vals))\n           ; END Question 20\n           ))\n        (else\n         ; BEGIN Question 20\n         (map analyze expr) ;;\n         ; END Question 20\n         )))\n\n;; Problem 21 (optional)\n;; Draw the hax image using turtle graphics.\n(define (hax d k)\n  ; BEGIN Question 21\n  'REPLACE-THIS-LINE\n  )\n  ; END Question 21\n\n\n\n(analyze '(lambda (x) a (let ((a x)) a)))\n",
            "scheme.py": "\"\"\"A Scheme interpreter and its read-eval-print loop.\"\"\"\n\nfrom scheme_primitives import *\nfrom scheme_reader import *\nfrom ucb import main, trace\n\n##############\n# Eval/Apply #\n##############\n\ndef scheme_eval(expr, env, _=None): # Optional third argument is ignored\n    \"\"\"Evaluate Scheme expression EXPR in environment ENV.\n\n    >>> expr = read_line(\"(+ 2 2)\")\n    >>> expr\n    Pair('+', Pair(2, Pair(2, nil)))\n    >>> scheme_eval(expr, create_global_frame())\n    4\n    \"\"\"\n    # Atoms\n    assert expr is not None\n    if scheme_symbolp(expr):\n        return env.lookup(expr)\n    elif self_evaluating(expr):\n        return expr\n\n    # Combinations\n    if not scheme_listp(expr):\n        raise SchemeError(\"malformed list: {0}\".format(str(expr)))\n    first, rest = expr.first, expr.second\n    if scheme_symbolp(first) and first in SPECIAL_FORMS:\n        result = SPECIAL_FORMS[first](rest, env)\n    else:\n        procedure = scheme_eval(first, env)\n        args = rest.map(lambda operand: scheme_eval(operand, env))\n        result = scheme_apply(procedure, args, env)\n    return result\n\ndef self_evaluating(expr):\n    \"\"\"Return whether EXPR evaluates to itself.\"\"\"\n    return scheme_atomp(expr) or scheme_stringp(expr) or expr is okay\n\n\ndef scheme_apply(procedure, args, env):\n    \"\"\"Apply Scheme PROCEDURE to argument values ARGS in environment ENV.\"\"\"\n    if isinstance(procedure, PrimitiveProcedure):\n        return apply_primitive(procedure, args, env)\n    elif isinstance(procedure, UserDefinedProcedure):\n        new_env = make_call_frame(procedure, args, env)\n        return eval_all(procedure.body, new_env)\n    else:\n        raise SchemeError(\"cannot call: {0}\".format(str(procedure)))\n\ndef apply_primitive(procedure, args_scheme_list, env):\n    \"\"\"Apply PrimitiveProcedure PROCEDURE to ARGS_SCHEME_LIST in ENV.\n\n    >>> env = create_global_frame()\n    >>> plus = env.bindings[\"+\"]\n    >>> twos = Pair(2, Pair(2, nil))\n    >>> apply_primitive(plus, twos, env)\n    4\n    \"\"\"\n    # Convert a Scheme list to a Python list\n    args = []\n    while args_scheme_list is not nil:\n        args.append(args_scheme_list.first)\n        args_scheme_list = args_scheme_list.second\n    # BEGIN Question 4\n    if procedure.use_env is True:\n        args.append(env)\n    try:\n        return procedure.fn(*args)\n    except TypeError:\n        raise SchemeError\n\n    # END Question 4\n\ndef eval_all(expressions, env):\n    \"\"\"Evaluate a Scheme list of EXPRESSIONS & return the value of the last.\"\"\"\n    # BEGIN Question 7\n    if expressions == nil:\n        return okay\n    if expressions.second != nil:\n        scheme_eval(expressions.first, env)\n        return eval_all(expressions.second, env)\n    return scheme_eval(expressions.first, env, True)\n    # END Question 7\n\ndef make_call_frame(procedure, args, env):\n    \"\"\"Make a frame that binds the formal parameters of PROCEDURE to ARGS.\"\"\"\n    # BEGIN Question 12\n    if isinstance(procedure, MuProcedure):\n        return env.make_child_frame(procedure.formals, args)\n    return procedure.env.make_child_frame(procedure.formals, args)\n    # END Question 12\n\n################\n# Environments #\n################\n\nclass Frame:\n    \"\"\"An environment frame binds Scheme symbols to Scheme values.\"\"\"\n\n    def __init__(self, parent):\n        \"\"\"An empty frame with a PARENT frame (which may be None).\"\"\"\n        self.bindings = {}\n        self.parent = parent\n\n    def __repr__(self):\n        if self.parent is None:\n            return \"<Global Frame>\"\n        else:\n            s = sorted('{0}: {1}'.format(k,v) for k,v in self.bindings.items())\n            return \"<{{{0}}} -> {1}>\".format(', '.join(s), repr(self.parent))\n\n    def lookup(self, symbol):\n        \"\"\"Return the value bound to SYMBOL.  Errors if SYMBOL is not found.\"\"\"\n        # BEGIN Question 3\n        if symbol in self.bindings.keys():\n            return self.bindings[symbol]\n        elif self.parent != None:\n            return self.parent.lookup(symbol)\n        # END Question 3\n        raise SchemeError(\"unknown identifier: {0}\".format(symbol))\n\n    def make_child_frame(self, formals, vals):\n        \"\"\"Return a new local frame whose parent is SELF, in which the symbols\n        in a Scheme list of formal parameters FORMALS are bound to the Scheme\n        values in the Scheme list VALS. Raise an error if too many or too few\n        vals are given.\n\n        >>> env = create_global_frame()\n        >>> formals, expressions = read_line(\"(a b c)\"), read_line(\"(1 2 3)\")\n        >>> env.make_child_frame(formals, expressions)\n        <{a: 1, b: 2, c: 3} -> <Global Frame>>\n        \"\"\"\n        if(len(vals)!=len(formals)):\n            raise SchemeError(\"Number of inputted argument values does not match with the number of formal parameters.\")\n        child = Frame(self) # Create a new child with self as the parent\n        while vals!=nil:\n            child.define(formals.first,vals.first)\n            formals=formals.second\n            vals=vals.second\n        return child\n\n    def define(self, symbol, value):\n        \"\"\"Define Scheme SYMBOL to have VALUE.\"\"\"\n        self.bindings[symbol] = value\n\nclass UserDefinedProcedure:\n    \"\"\"A procedure defined by an expression.\"\"\"\n\nclass LambdaProcedure(UserDefinedProcedure):\n    \"\"\"A procedure defined by a lambda expression or a define form.\"\"\"\n\n    def __init__(self, formals, body, env):\n        \"\"\"A procedure with formal parameter list FORMALS (a Scheme list),\n        a Scheme list of BODY expressions, and a parent environment that\n        starts with Frame ENV.\n        \"\"\"\n        self.formals = formals\n        self.body = body\n        self.env = env\n\n    def __str__(self):\n        return str(Pair(\"lambda\", Pair(self.formals, self.body)))\n\n    def __repr__(self):\n        return \"LambdaProcedure({!r}, {!r}, {!r})\".format(\n            self.formals, self.body, self.env)\n\n#################\n# Special forms #\n#################\n\ndef do_define_form(expressions, env):\n    \"\"\"Evaluate a define form.\"\"\"\n    check_form(expressions, 2)\n    target = expressions.first\n    if scheme_symbolp(target):\n        check_form(expressions, 2, 2)\n        # BEGIN Question 5A\n        env.define(expressions.first, scheme_eval(expressions.second.first, env))\n        return expressions.first\n        # END Question 5A\n    elif isinstance(target, Pair) and scheme_symbolp(target.first):\n        # BEGIN Question 9A\n        if expressions.first.second != nil:\n            parameters = expressions.first.second\n        else:\n            parameters = nil\n        env.define(expressions.first.first, scheme_eval(Pair(\"lambda\", Pair(parameters, expressions.second)), env))\n        return expressions.first.first\n        # END Question 9A\n    else:\n        bad = target.first if isinstance(target, Pair) else target\n        raise SchemeError(\"Non-symbol: {}\".format(bad))\n\ndef do_quote_form(expressions, env):\n    \"\"\"Evaluate a quote form.\"\"\"\n    check_form(expressions, 1, 1)\n    # BEGIN Question 6B\n    return expressions.first\n    # END Question 6B\n\ndef do_begin_form(expressions, env):\n    \"\"\"Evaluate begin form.\"\"\"\n    check_form(expressions, 1)\n    return eval_all(expressions, env)\n\ndef do_lambda_form(expressions, env):\n    \"\"\"Evaluate a lambda form.\"\"\"\n    check_form(expressions, 2)\n    formals = expressions.first\n    # BEGIN Question 8\n    if isinstance(formals, Pair) or formals not in env.bindings:\n        check_formals(formals)\n        return LambdaProcedure(formals, expressions.second, env)\n    #funny changes not legit\n    elif not isinstance(formals, Pair) and formals in env.bindings and isinstance(expressions.second, Pair):\n        return LambdaProcedure(env.bindings[formals], Pair(env.bindings[expressions.second.first], nil), env)\n\n\n\n    # END Question 8\n\ndef do_if_form(expressions, env):\n    \"\"\"Evaluate an if form.\"\"\"\n    check_form(expressions, 2, 3)\n    # BEGIN Question 13\n    consequent = expressions.second.first\n    condition = scheme_eval(expressions.first, env)\n    if condition is not False:\n        condition = True\n    if expressions.second.second == nil:\n        alternative = okay\n    else:\n        alternative = expressions.second.second.first\n    if condition:\n        return scheme_eval(consequent, env, True)\n    else:\n        return scheme_eval(alternative, env, True)\n\n    # END Question 13\n\ndef do_and_form(expressions, env):\n    \"\"\"Evaluate a short-circuited and form.\"\"\"\n    # BEGIN Question 14B\n    if expressions == nil:\n        return True\n    b=False\n    if expressions.second == nil:\n        b=True\n    condition = scheme_eval(expressions.first, env, b)\n    value = condition\n    if condition is not False:\n        condition = True\n    if expressions.second == nil:\n        return value\n    elif condition == False:\n        return False\n    else:\n        return do_and_form(expressions.second, env)\n\n    # END Question 14B\n\ndef do_or_form(expressions, env):\n    \"\"\"Evaluate a short-circuited or form.\"\"\"\n    # BEGIN Question 14B\n    if expressions == nil:\n        return False\n    b=False\n    if expressions.second == nil:\n        b=True\n    condition = scheme_eval(expressions.first, env, b)\n    value = condition\n    if condition is not False:\n        condition = True\n    if condition == True:\n        return value\n    elif expressions.second == nil:\n        return False\n    else:\n        return do_or_form(expressions.second, env)\n    # END Question 14B\n\ndef do_cond_form(expressions, env):\n    \"\"\"Evaluate a cond form.\"\"\"\n    num_clauses = len(expressions)\n    i = 0\n    while expressions is not nil:\n        clause = expressions.first\n        check_form(clause, 1)\n        if clause.first == \"else\":\n            if i < num_clauses-1:\n                raise SchemeError(\"else must be last\")\n            test = True\n        else:\n            test = scheme_eval(clause.first, env)\n        if scheme_true(test):\n            # BEGIN Question 15A\n            if clause.second!=nil:\n                clause=clause.second\n                while(clause.second!=nil):\n                    scheme_eval(clause.first,env)\n                    clause=clause.second\n                return scheme_eval(clause.first,env, True)\n            else:\n                return test\n            # END Question 15A\n        expressions = expressions.second\n        i += 1\n    return okay\n\ndef do_let_form(expressions, env):\n    \"\"\"Evaluate a let form.\"\"\"\n    check_form(expressions, 2)\n    let_env = make_let_frame(expressions.first, env)\n    return eval_all(expressions.second, let_env)\n\ndef make_let_frame(bindings, env):\n    \"\"\"Create a frame containing bindings from a let expression.\"\"\"\n    if not scheme_listp(bindings):\n        raise SchemeError(\"bad bindings list in let form\")\n    # BEGIN Question 16\n    formals = nil\n    vals = nil\n    while bindings is not nil:\n        check_form(bindings.first, 2, 2)\n        formals = Pair(bindings.first.first, formals)\n        vals = Pair(scheme_eval(bindings.first.second.first, env), vals)\n        if bindings.second is not nil:\n            bindings = Pair(bindings.second.first, bindings.second.second)\n        else:\n            bindings = nil\n    check_formals(formals)\n    return env.make_child_frame(formals, vals)\n    # END Question 16\n\nSPECIAL_FORMS = {\n    \"and\": do_and_form,\n    \"begin\": do_begin_form,\n    \"cond\": do_cond_form,\n    \"define\": do_define_form,\n    \"if\": do_if_form,\n    \"lambda\": do_lambda_form,\n    \"let\": do_let_form,\n    \"or\": do_or_form,\n    \"quote\": do_quote_form,\n}\n\n# Utility methods for checking the structure of Scheme programs\n\ndef check_form(expr, min, max=float('inf')):\n    \"\"\"Check EXPR is a proper list whose length is at least MIN and no more\n    than MAX (default: no maximum). Raises a SchemeError if this is not the\n    case.\n    \"\"\"\n    if not scheme_listp(expr):\n        raise SchemeError(\"badly formed expression: \" + str(expr))\n    length = len(expr)\n    if length < min:\n        raise SchemeError(\"too few operands in form\")\n    elif length > max:\n        raise SchemeError(\"too many operands in form\")\n\ndef check_formals(formals):\n    \"\"\"Check that FORMALS is a valid parameter list, a Scheme list of symbols\n    in which each symbol is distinct. Raise a SchemeError if the list of\n    formals is not a well-formed list of symbols or if any symbol is repeated.\n\n    >>> check_formals(read_line(\"(a b c)\"))\n    \"\"\"\n    # BEGIN Question 11B\n    \"*** REPLACE THIS LINE ***\"\n    x=formals\n    d=[]\n    while x!=nil:\n        if not scheme_symbolp(x.first):\n            raise SchemeError(\"Non-symbol as argument\")\n        if scheme_symbolp(x.second):\n            raise SchemeError(\"Malformed List\")\n        if x.first in d:\n            raise SchemeError(\"Duplicate Symbol\")\n        d.append(x.first)\n        x=x.second\n    # END Question 11B\n\n#################\n# Dynamic Scope #\n#################\n\nclass MuProcedure(UserDefinedProcedure):\n    \"\"\"A procedure defined by a mu expression, which has dynamic scope.\n     _________________\n    < Scheme is cool! >\n     -----------------\n            \\   ^__^\n             \\  (oo)\\_______\n                (__)\\       )\\/\\\n                    ||----w |\n                    ||     ||\n    \"\"\"\n\n    def __init__(self, formals, body):\n        \"\"\"A procedure with formal parameter list FORMALS (a Scheme list) and a\n        Scheme list of BODY expressions.\n        \"\"\"\n        self.formals = formals\n        self.body = body\n\n    def __str__(self):\n        return str(Pair(\"mu\", Pair(self.formals, self.body)))\n\n    def __repr__(self):\n        return \"MuProcedure({!r}, {!r})\".format(self.formals, self.body)\n\n\ndef do_mu_form(expressions, env):\n    \"\"\"Evaluate a mu form.\"\"\"\n    check_form(expressions, 2)\n    formals = expressions.first\n    check_formals(formals)\n    # BEGIN Question 17\n    return MuProcedure(formals, expressions.second)\n    # END Question 17\n\nSPECIAL_FORMS[\"mu\"] = do_mu_form\n\n\n##################\n# Tail Recursion #\n##################\n\nclass Evaluate:\n    \"\"\"An expression EXPR to be evaluated in environment ENV.\"\"\"\n    def __init__(self, expr, env):\n        self.expr = expr\n        self.env = env\n\ndef scheme_optimized_eval(expr, env, tail=False):\n    \"\"\"Evaluate Scheme expression EXPR in environment ENV.\"\"\"\n    # Evaluate Atoms\n    assert expr is not None\n    if scheme_symbolp(expr):\n        return env.lookup(expr)\n    elif self_evaluating(expr):\n        return expr\n\n    if tail:\n        # BEGIN Extra Credit\n        return Evaluate(expr,env)\n        # END Extra Credit\n    else:\n        result = Evaluate(expr, env)\n\n    while isinstance(result, Evaluate):\n        expr, env = result.expr, result.env\n        # All non-atomic expressions are lists (combinations)\n        if not scheme_listp(expr):\n            raise SchemeError(\"malformed list: {0}\".format(str(expr)))\n        first, rest = expr.first, expr.second\n        if (scheme_symbolp(first) and first in SPECIAL_FORMS):\n            result = SPECIAL_FORMS[first](rest, env)\n        else:\n            procedure = scheme_eval(first, env)\n            args = rest.map(lambda operand: scheme_eval(operand, env))\n            result = scheme_apply(procedure, args, env)\n    return result\n\ndef scheme_eval(expr, env, _=None): # Optional third argument is ignored\n    \"\"\"Evaluate Scheme expression EXPR in environment ENV.\n\n    >>> expr = read_line(\"(+ 2 2)\")\n    >>> expr\n    Pair('+', Pair(2, Pair(2, nil)))\n    >>> scheme_eval(expr, create_global_frame())\n    4\n    \"\"\"\n    # Atoms\n    assert expr is not None\n    if scheme_symbolp(expr):\n        return env.lookup(expr)\n    elif self_evaluating(expr):\n        return expr\n\n    # Combinations\n    if not scheme_listp(expr):\n        raise SchemeError(\"malformed list: {0}\".format(str(expr)))\n    first, rest = expr.first, expr.second\n    if scheme_symbolp(first) and first in SPECIAL_FORMS:\n        result = SPECIAL_FORMS[first](rest, env)\n    else:\n        procedure = scheme_eval(first, env)\n        args = rest.map(lambda operand: scheme_eval(operand, env))\n        result = scheme_apply(procedure, args, env)\n    return result\n\n################################################################\n# Uncomment the following line to apply tail call optimization #\n################################################################\nscheme_eval = scheme_optimized_eval\n\n\n################\n# Input/Output #\n################\n\ndef read_eval_print_loop(next_line, env, interactive=False, quiet=False,\n                         startup=False, load_files=()):\n    \"\"\"Read and evaluate input until an end of file or keyboard interrupt.\"\"\"\n    if startup:\n        for filename in load_files:\n            scheme_load(filename, True, env)\n    while True:\n        try:\n            src = next_line()\n            while src.more_on_line:\n                expression = scheme_read(src)\n                result = scheme_eval(expression, env)\n                if not quiet and result is not None:\n                    print(result)\n        except (SchemeError, SyntaxError, ValueError, RuntimeError) as err:\n            if (isinstance(err, RuntimeError) and\n                'maximum recursion depth exceeded' not in getattr(err, 'args')[0]):\n                raise\n            elif isinstance(err, RuntimeError):\n                print(\"Error: maximum recursion depth exceeded\")\n            else:\n                print(\"Error:\", err)\n        except KeyboardInterrupt:  # <Control>-C\n            if not startup:\n                raise\n            print()\n            print(\"KeyboardInterrupt\")\n            if not interactive:\n                return\n        except EOFError:  # <Control>-D, etc.\n            print()\n            return\n\ndef scheme_load(*args):\n    \"\"\"Load a Scheme source file. ARGS should be of the form (SYM, ENV) or (SYM,\n    QUIET, ENV). The file named SYM is loaded in environment ENV, with verbosity\n    determined by QUIET (default true).\"\"\"\n    if not (2 <= len(args) <= 3):\n        expressions = args[:-1]\n        raise SchemeError('\"load\" given incorrect number of arguments: '\n                          '{0}'.format(len(expressions)))\n    sym = args[0]\n    quiet = args[1] if len(args) > 2 else True\n    env = args[-1]\n    if (scheme_stringp(sym)):\n        sym = eval(sym)\n    check_type(sym, scheme_symbolp, 0, \"load\")\n    with scheme_open(sym) as infile:\n        lines = infile.readlines()\n    args = (lines, None) if quiet else (lines,)\n    def next_line():\n        return buffer_lines(*args)\n\n    read_eval_print_loop(next_line, env, quiet=quiet)\n    return okay\n\ndef scheme_open(filename):\n    \"\"\"If either FILENAME or FILENAME.scm is the name of a valid file,\n    return a Python file opened to it. Otherwise, raise an error.\"\"\"\n    try:\n        return open(filename)\n    except IOError as exc:\n        if filename.endswith('.scm'):\n            raise SchemeError(str(exc))\n    try:\n        return open(filename + '.scm')\n    except IOError as exc:\n        raise SchemeError(str(exc))\n\ndef create_global_frame():\n    \"\"\"Initialize and return a single-frame environment with built-in names.\"\"\"\n    env = Frame(None)\n    env.define(\"eval\", PrimitiveProcedure(scheme_eval, True))\n    env.define(\"apply\", PrimitiveProcedure(scheme_apply, True))\n    env.define(\"load\", PrimitiveProcedure(scheme_load, True))\n    add_primitives(env)\n    return env\n\n@main\ndef run(*argv):\n    import argparse\n    parser = argparse.ArgumentParser(description='CS 61A Scheme interpreter')\n    parser.add_argument('-load', '-i', action='store_true',\n                       help='run file interactively')\n    parser.add_argument('file', nargs='?',\n                        type=argparse.FileType('r'), default=None,\n                        help='Scheme file to run')\n    args = parser.parse_args()\n\n    next_line = buffer_input\n    interactive = True\n    load_files = []\n\n    if args.file is not None:\n        if args.load:\n            load_files.append(getattr(args.file, 'name'))\n        else:\n            lines = args.file.readlines()\n            def next_line():\n                return buffer_lines(lines)\n            interactive = False\n\n    read_eval_print_loop(next_line, create_global_frame(), startup=True,\n                         interactive=interactive, load_files=load_files)\n    tscheme_exitonclick()\n",
            "scheme_reader.py": "\"\"\"This module implements the built-in data types of the Scheme language, along\nwith a parser for Scheme expressions.\n\nIn addition to the types defined in this file, some data types in Scheme are\nrepresented by their corresponding type in Python:\n    number:       int or float\n    symbol:       string\n    boolean:      bool\n    unspecified:  None\n\nThe __repr__ method of a Scheme value will return a Python expression that\nwould be evaluated to the value, where possible.\n\nThe __str__ method of a Scheme value will return a Scheme expression that\nwould be read to the value, where possible.\n\"\"\"\n\nfrom ucb import main, trace, interact\nfrom scheme_tokens import tokenize_lines, DELIMITERS\nfrom buffer import Buffer, InputReader, LineReader\n\n# Pairs and Scheme lists\n\nclass Pair:\n    \"\"\"A pair has two instance attributes: first and second.  For a Pair to be\n    a well-formed list, second is either a well-formed list or nil.  Some\n    methods only apply to well-formed lists.\n\n    >>> s = Pair(1, Pair(2, nil))\n    >>> s\n    Pair(1, Pair(2, nil))\n    >>> print(s)\n    (1 2)\n    >>> print(s.map(lambda x: x+4))\n    (5 6)\n    \"\"\"\n    def __init__(self, first, second):\n        self.first = first\n        self.second = second\n\n    def __repr__(self):\n        return \"Pair({0}, {1})\".format(repr(self.first), repr(self.second))\n\n    def __str__(self):\n        s = \"(\" + str(self.first)\n        second = self.second\n        while isinstance(second, Pair):\n            s += \" \" + str(second.first)\n            second = second.second\n        if second is not nil:\n            s += \" . \" + str(second)\n        return s + \")\"\n\n    def __len__(self):\n        n, second = 1, self.second\n        while isinstance(second, Pair):\n            n += 1\n            second = second.second\n        if second is not nil:\n            raise TypeError(\"length attempted on improper list\")\n        return n\n\n    def __eq__(self, p):\n        if not isinstance(p, Pair):\n            return False\n        return self.first == p.first and self.second == p.second\n\n    def map(self, fn):\n        \"\"\"Return a Scheme list after mapping Python function FN to SELF.\"\"\"\n        mapped = fn(self.first)\n        if self.second is nil or isinstance(self.second, Pair):\n            return Pair(mapped, self.second.map(fn))\n        else:\n            raise TypeError(\"ill-formed list\")\n\nclass nil:\n    \"\"\"The empty list\"\"\"\n\n    def __repr__(self):\n        return \"nil\"\n\n    def __str__(self):\n        return \"()\"\n\n    def __len__(self):\n        return 0\n\n    def map(self, fn):\n        return self\n\nnil = nil() # Assignment hides the nil class; there is only one instance\n\n# Scheme list parser\n\n\ndef scheme_read(src):\n    \"\"\"Read the next expression from SRC, a Buffer of tokens.\n\n    >>> lines = [\"(+ 1 \", \"(+ 23 4)) (\"]\n    >>> src = Buffer(tokenize_lines(lines))\n    >>> print(scheme_read(src))\n    (+ 1 (+ 23 4))\n    >>> read_line(\"'hello\")\n    Pair('quote', Pair('hello', nil))\n    >>> print(read_line(\"(car '(1 2))\"))\n    (car (quote (1 2)))\n    \"\"\"\n    if src.current() is None:\n        raise EOFError\n    val = src.pop()\n    if val == \"nil\":\n        return nil\n    elif val not in DELIMITERS:\n        return val\n    elif val == \"'\":\n        # BEGIN Question 1\n        first = 'quote'\n        rest = Pair(scheme_read(src), nil)\n        return Pair(first, rest)\n        # END Question 1\n    elif val == \"(\":\n        return read_tail(src)\n    else:\n        raise SyntaxError(\"unexpected token: {0}\".format(val))\n\ndef read_tail(src):\n    \"\"\"Return the remainder of a list in SRC, starting before an element or ).\n\n    >>> read_tail(Buffer(tokenize_lines([\")\"])))\n    nil\n    >>> read_tail(Buffer(tokenize_lines([\"2 3)\"])))\n    Pair(2, Pair(3, nil))\n    >>> read_tail(Buffer(tokenize_lines([\"2 (3 4))\"])))\n    Pair(2, Pair(Pair(3, Pair(4, nil)), nil))\n    >>> read_line(\"(1 . 2)\")\n    Pair(1, 2)\n    >>> read_line(\"(1 2 . 3)\")\n    Pair(1, Pair(2, 3))\n    >>> read_line(\"(1 . 2 3)\")\n    Traceback (most recent call last):\n      ...\n    SyntaxError: expected one element after .\n    >>> scheme_read(Buffer(tokenize_lines([\"(1\", \"2 .\", \"'(3 4))\", \"4\"])))\n    Pair(1, Pair(2, Pair('quote', Pair(Pair(3, Pair(4, nil)), nil))))\n    \"\"\"\n    try:\n        if src.current() is None:\n            raise SyntaxError(\"unexpected end of file\")\n        elif src.current() == \")\":\n            src.pop()\n            return nil\n        elif src.current() == \".\":\n            # BEGIN Question 2\n            src.pop()\n            val = scheme_read(src)\n            if src.current() == \")\":\n                src.pop()\n                return val            \n            else:\n                raise SyntaxError(\"Value after mal-formed list\")\n            # END Question 2\n        else:\n            first = scheme_read(src)\n            rest = read_tail(src)\n            return Pair(first, rest)\n    except EOFError:\n        raise SyntaxError(\"unexpected end of file\")\n\n# Convenience methods\n\ndef buffer_input(prompt=\"scm> \"):\n    \"\"\"Return a Buffer instance containing interactive input.\"\"\"\n    return Buffer(tokenize_lines(InputReader(prompt)))\n\ndef buffer_lines(lines, prompt=\"scm> \", show_prompt=False):\n    \"\"\"Return a Buffer instance iterating through LINES.\"\"\"\n    if show_prompt:\n        input_lines = lines\n    else:\n        input_lines = LineReader(lines, prompt)\n    return Buffer(tokenize_lines(input_lines))\n\ndef read_line(line):\n    \"\"\"Read a single string LINE as a Scheme expression.\"\"\"\n    return scheme_read(Buffer(tokenize_lines([line])))\n\n# Interactive loop\n\n@main\ndef read_print_loop():\n    \"\"\"Run a read-print loop for Scheme expressions.\"\"\"\n    while True:\n        try:\n            src = buffer_input(\"read> \")\n            while src.more_on_line:\n                expression = scheme_read(src)\n                print(\"str :\", expression)\n                print(\"repr:\", repr(expression))\n        except (SyntaxError, ValueError) as err:\n            print(type(err).__name__ + \":\", err)\n        except (KeyboardInterrupt, EOFError):  # <Control>-D, etc.\n            print()\n            return\n",
            "tests.scm": ";;; Test cases for Scheme.\n;;;\n;;; In order to run only a prefix of these examples, add the line\n;;;\n;;; (exit)\n;;;\n;;; after the last test you wish to run.\n\n;;; **********************************\n\n(define jet_fuel_melting_steel_beams False)\n;expect jet_fuel_melting_steel_beams\n\n(define bush_did (/ 9 11))\n;expect bush_did\n\n(define john_cena True)\n;expect john_cena\n\n(or jet_fuel_melting_steel_beams john_cena)\n;expect True\n\n)(define a \"scheme_read test\")\n; expect Error ; a\n\n(* 1 (+ 1 1)\n5 6)\n; expect 60\n\n;for if condition\n(if False (display 'hello) (display 'world))\n;expect worldokay\n\n(if True (display 'hello))\n;expect hellookay\n\n(define x 1)\n(and 3 (define x (+ x 2)))\n;expect x\n\n(cond (False))\n;expect okay\n\n(let ((x 1) (x 2) (y 3)) (+ x y))\n;expect Error:duplicate bindings\n\n\n\n(define f (mu (x) (+ x y)))\n(define g (lambda (x y) (f (+ x x))))\n(g 6 4)\n;expect 16\n\n\n\n(+ (- 10 5) 10)\n;expect 15\n\n(define a 5)\n(define b a)\nb\n;expect 5\n\n'('hello )\n;expect ((quote hello))\n\n(define a 1)\n(define b 2)\n(car (list 'a b))\n;expect a\n(car '(list a b))\n;expect list\n\n(begin (+ 2 3) (begin (+ 5 6) (- 1 1)))\n;expect 0\n\n\n()\n; expect ()\n\n(+ (* 2 3 (/ 8 4) (- 7 3)) 2)\n; expect 50\n\n(null? ())\n; expect True\n\n#f\n; expect False\n\nnil\n; expect ()\n\n;;; testing do_define_form\n\n(define x 3)\n; expect x\n(define y 2)\n; expect y\n(+ y x)\n; expect 5\n\n(define x 10)\n; expect x\nx\n; expect 10\n\n;;; testing do_quote_form\n\n(define eecs 'masterrace)\n; expect eecs\neecs\n; expect masterrace\n\n'$_$\n; expect $_$\n\n'(hi . ( sup . ( bye)))\n; expect (hi sup bye)\n\n(+ 10 '5)\n; expect 15\n\n(car '(peanut_butter jelly))\n; expect peanut_butter\n(cdr '(peanut_butter jelly))\n; expect (jelly)\n\n;;; testing begin form\n\n(begin (car '(hi bye)) (+ 2 3))\n; expect 5\n\n(begin (display 'dank) 5)\n; expect dank5\n\n(begin 20 'dank)\n; expect dank\n\n;;; testing do_define_form\n\n(define (add3 x) (+ x 3))\n; expect add3\nadd3\n; expect (lambda (x) (+ x 3))\n\n;;; testing do_lambda_form\n\n(lambda (x y) (* x y))\n; expect (lambda (x y) (* x y))\n\n;;; testing check_formals\n\n(define (1 2) (+ x x))\n; expect Error: bad argument to define\n\n(define (x x x) (+ 3 x))\n; expect Error: invalid list of formal parameters\n\n;;; testing do_if_form\n\n(if (= 3 2) 'dank 30)\n; expect 30\n\n(if 'jack 'bowen 'denero)\n; expect bowen\n\n(if (= 2 100) 'dank)\n; expect okay\n\n;;; testing do_and_form and do_or_form\n\n(and)\n; expect True\n\n(or)\n; expect False\n\n(and 'crossroads 'is 'literallyhiv)\n; expect literallyhiv\n\n(and 20 (= 1 2) 'doot)\n; expect False\n\n(or 'doot (/ 1 0) 9000)\n; expect doot\n\n(or #f 2 3 4)\n; expect 2\n\n(or 1)\n; expect 1\n\n;;; testing do_cond_form\n\n(cond ((= 4 2) 'doot)\n      ((= 3 3) 'dootdoot)\n      (else 'fuccbois))\n;  expect dootdoot\n\n(cond ((= 2 3) 30)\n      ((= 6 3) 1)\n      (else 5))\n; expect 5\n\n(cond ((= 34 1) 3)\n      ((= 1 1))\n      (else 100))\n; expect True\n\n(cond ((= 1 2) 'skeletal)\n      ((= 1 1) (display 'dankest) 34)\n      (else 0))\n; expect dankest34\n\n(cond (50))\n; expect 50\n\n(cond ((= 2 3)) ('doot))\n; expect doot\n\n;;; testing do_let_form\n\n(define x 'this)\n; expect x\n(define y 'that)\n; expect y\n(let ((x 10) (y (+ 5 20))) (list x y))\n; expect (10 25)\n(list x y)\n; expect (this that)\n\n(let ((z 3)) (display ':) z)\n; expect :3\n\n;;; testing do_mu_form\n\n(define f (mu (x) (+ x y)))\n; expect f\n(define g (lambda (x y) (f (+ x x))))\n; expect g\n(g 3 7)\n; expect 13\n\n(define f (mu (x) (+ (+ x 3) y)))\n; expect f\n(define g (lambda (x y) (f (* y x))))\n; expect g\n(g 1 2)\n; expect 7\n\n\n(lambda (x y) 5)\n;expect (lambda (x y) 5)\n\n((lambda (x) (display x) (display (+ x 1))) 2)\n;expect 23okay\n\n(define (test arg) (+ arg 1))\n(test 1)\n;expect 2\n\n(define a 3)\n(define (f x) (define a 4))\na\n;expect 3\n\n((lambda (x) (* x 2)) 7)\n;expect 14\n\n(define x 3)\n(define y 4)\n(and (if (= x 3) True False) (if (= y 4) True False))\n;expect True\n\n((1 2) . 3 4)\n;expect Error: \"Value after mal-formed list\"\n\n(cond\n  ((= x 1) \"x = 1\")\n  ((= x 2) \"x = 2\")\n  (else \"x does not equal 1 or 2\"))\n;expect \"x does not equal 1 or 2\"\n\n(define (map proc items)\n  (if (null? items)\n      nil\n      (cons (proc (car items))\n            (map proc (cdr items)))))\n\n(define (merge comp list1 list2)\n    ; *** YOUR CODE HERE ***\n    (cond ((null? list1) list2)\n          ((null? list2) list1)\n          ((comp (car list1)\n                (car list2))\n          (cons\n                   (car list1)\n                   (merge comp (cdr list1) list2)))\n          (else (cons\n                     (car list2)\n                     (merge comp list1 (cdr list2))))))\n\n(merge > (list 6 4 2) (list 5 3 1))\n;expect (6 5 4 3 2 1)\n\n(define (list-partitions total max-pieces max-value)\n  ; *** YOUR CODE HERE ***\n  (cond ((< total 0) nil)\n        ((= total 0) (cons nil nil))  ;if feasible, create an empty spot for adding values\n        ((= max-value 0) nil)\n        ((= max-pieces 0) nil)\n        (else (append\n                (add-front max-value (list-partitions (- total max-value) (- max-pieces 1) max-value))\n                (list-partitions total max-pieces (- max-value 1))))))\n\n(define (add-front value lists)\n  (map (lambda (x) (cons value x)) lists))\n\n(list-partitions 5 5 2)\n;expect ((2 2 1) (2 1 1 1) (1 1 1 1 1))\n;;; **********************************\n\n;;; These are examples from several sections of \"The Structure\n;;; and Interpretation of Computer Programs\" by Abelson and Sussman.\n\n;;; License: Creative Commons share alike with attribution\n\n;;; 1.1.1\n\n10\n; expect 10\n\n(+ 137 349)\n; expect 486\n\n(- 1000 334)\n; expect 666\n\n(* 5 99)\n; expect 495\n\n(/ 10 5)\n; expect 2\n\n(+ 2.7 10)\n; expect 12.7\n\n(+ 21 35 12 7)\n; expect 75\n\n(* 25 4 12)\n; expect 1200\n\n(+ (* 3 5) (- 10 6))\n; expect 19\n\n(+ (* 3 (+ (* 2 4) (+ 3 5))) (+ (- 10 7) 6))\n; expect 57\n\n(+ (* 3\n      (+ (* 2 4)\n         (+ 3 5)))\n   (+ (- 10 7)\n      6))\n; expect 57\n\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n;;; Move the following (exit) line to run additional tests. ;;;\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n\n\n;;; 1.1.2\n\n(define size 2)\n; expect size\nsize\n; expect 2\n\n(* 5 size)\n; expect 10\n\n(define pi 3.14159)\n(define radius 10)\n(* pi (* radius radius))\n; expect 314.159\n\n(define circumference (* 2 pi radius))\ncircumference\n; expect 62.8318\n\n;;; 1.1.4\n\n(define (square x) (* x x))\n; expect square\n(square 21)\n; expect 441\n\n(define square (lambda (x) (* x x))) ; See Section 1.3.2\n(square 21)\n; expect 441\n\n(square (+ 2 5))\n; expect 49\n\n(square (square 3))\n; expect 81\n\n(define (sum-of-squares x y)\n  (+ (square x) (square y)))\n(sum-of-squares 3 4)\n; expect 25\n\n(define (f a)\n  (sum-of-squares (+ a 1) (* a 2)))\n(f 5)\n; expect 136\n\n;;; 1.1.6\n\n(define (abs x)\n  (cond ((> x 0) x)\n        ((= x 0) 0)\n        ((< x 0) (- x))))\n(abs -3)\n; expect 3\n\n(abs 0)\n; expect 0\n\n(abs 3)\n; expect 3\n\n(define (a-plus-abs-b a b)\n  ((if (> b 0) + -) a b))\n(a-plus-abs-b 3 -2)\n; expect 5\n\n;;; 1.1.7\n\n(define (sqrt-iter guess x)\n  (if (good-enough? guess x)\n      guess\n      (sqrt-iter (improve guess x)\n                 x)))\n(define (improve guess x)\n  (average guess (/ x guess)))\n(define (average x y)\n  (/ (+ x y) 2))\n(define (good-enough? guess x)\n  (< (abs (- (square guess) x)) 0.001))\n(define (sqrt x)\n  (sqrt-iter 1.0 x))\n(sqrt 9)\n; expect 3.00009155413138\n\n(sqrt (+ 100 37))\n; expect 11.704699917758145\n\n(sqrt (+ (sqrt 2) (sqrt 3)))\n; expect 1.7739279023207892\n\n(square (sqrt 1000))\n; expect 1000.000369924366\n\n;;; 1.1.8\n\n(define (sqrt x)\n  (define (good-enough? guess)\n    (< (abs (- (square guess) x)) 0.001))\n  (define (improve guess)\n    (average guess (/ x guess)))\n  (define (sqrt-iter guess)\n    (if (good-enough? guess)\n        guess\n        (sqrt-iter (improve guess))))\n  (sqrt-iter 1.0))\n(sqrt 9)\n; expect 3.00009155413138\n\n(sqrt (+ 100 37))\n; expect 11.704699917758145\n\n(sqrt (+ (sqrt 2) (sqrt 3)))\n; expect 1.7739279023207892\n\n(square (sqrt 1000))\n; expect 1000.000369924366\n\n;;; 1.3.1\n\n(define (cube x) (* x x x))\n(define (sum term a next b)\n  (if (> a b)\n      0\n      (+ (term a)\n         (sum term (next a) next b))))\n(define (inc n) (+ n 1))\n(define (sum-cubes a b)\n  (sum cube a inc b))\n(sum-cubes 1 10)\n; expect 3025\n\n(define (identity x) x)\n(define (sum-integers a b)\n  (sum identity a inc b))\n(sum-integers 1 10)\n; expect 55\n\n;;; 1.3.2\n\n((lambda (x y z) (+ x y (square z))) 1 2 3)\n; expect 12\n\n(define (f x y)\n  (let ((a (+ 1 (* x y)))\n        (b (- 1 y)))\n    (+ (* x (square a))\n       (* y b)\n       (* a b))))\n(f 3 4)\n; expect 456\n\n(define x 5)\n(+ (let ((x 3))\n     (+ x (* x 10)))\n   x)\n; expect 38\n\n(let ((x 3)\n      (y (+ x 2)))\n  (* x y))\n; expect 21\n\n;;; 2.1.1\n\n(define (add-rat x y)\n  (make-rat (+ (* (numer x) (denom y))\n               (* (numer y) (denom x)))\n            (* (denom x) (denom y))))\n(define (sub-rat x y)\n  (make-rat (- (* (numer x) (denom y))\n               (* (numer y) (denom x)))\n            (* (denom x) (denom y))))\n(define (mul-rat x y)\n  (make-rat (* (numer x) (numer y))\n            (* (denom x) (denom y))))\n(define (div-rat x y)\n  (make-rat (* (numer x) (denom y))\n            (* (denom x) (numer y))))\n(define (equal-rat? x y)\n  (= (* (numer x) (denom y))\n     (* (numer y) (denom x))))\n\n(define x (cons 1 2))\n(car x)\n; expect 1\n\n(cdr x)\n; expect 2\n\n(define x (cons 1 2))\n(define y (cons 3 4))\n(define z (cons x y))\n(car (car z))\n; expect 1\n\n(car (cdr z))\n; expect 3\n\nz\n; expect ((1 . 2) 3 . 4)\n\n(define (make-rat n d) (cons n d))\n(define (numer x) (car x))\n(define (denom x) (cdr x))\n(define (print-rat x)\n  (display (numer x))\n  (display '/)\n  (display (denom x))\n  (newline))\n(define one-half (make-rat 1 2))\n(print-rat one-half)\n; expect 1/2 ; okay\n\n(define one-third (make-rat 1 3))\n(print-rat (add-rat one-half one-third))\n; expect 5/6 ; okay\n\n(print-rat (mul-rat one-half one-third))\n; expect 1/6 ; okay\n\n(print-rat (add-rat one-third one-third))\n; expect 6/9 ; okay\n\n(define (gcd a b)\n  (if (= b 0)\n      a\n      (gcd b (remainder a b))))\n(define (make-rat n d)\n  (let ((g (gcd n d)))\n    (cons (/ n g) (/ d g))))\n(print-rat (add-rat one-third one-third))\n; expect 2/3 ; okay\n\n(define one-through-four (list 1 2 3 4))\none-through-four\n; expect (1 2 3 4)\n\n(car one-through-four)\n; expect 1\n\n(cdr one-through-four)\n; expect (2 3 4)\n\n(car (cdr one-through-four))\n; expect 2\n\n(cons 10 one-through-four)\n; expect (10 1 2 3 4)\n\n(cons 5 one-through-four)\n; expect (5 1 2 3 4)\n\n(define (map proc items)\n  (if (null? items)\n      nil\n      (cons (proc (car items))\n            (map proc (cdr items)))))\n(map abs (list -10 2.5 -11.6 17))\n; expect (10 2.5 11.6 17)\n\n(map (lambda (x) (* x x))\n     (list 1 2 3 4))\n; expect (1 4 9 16)\n\n(define (scale-list items factor)\n  (map (lambda (x) (* x factor))\n       items))\n(scale-list (list 1 2 3 4 5) 10)\n; expect (10 20 30 40 50)\n\n(define (count-leaves x)\n  (cond ((null? x) 0)\n        ((not (pair? x)) 1)\n        (else (+ (count-leaves (car x))\n                 (count-leaves (cdr x))))))\n(define x (cons (list 1 2) (list 3 4)))\n(count-leaves x)\n; expect 4\n\n(count-leaves (list x x))\n; expect 8\n\n;;; 2.2.3\n\n(define (odd? x) (= 1 (remainder x 2)))\n(define (filter predicate sequence)\n  (cond ((null? sequence) nil)\n        ((predicate (car sequence))\n         (cons (car sequence)\n               (filter predicate (cdr sequence))))\n        (else (filter predicate (cdr sequence)))))\n(filter odd? (list 1 2 3 4 5))\n; expect (1 3 5)\n\n(define (accumulate op initial sequence)\n  (if (null? sequence)\n      initial\n      (op (car sequence)\n          (accumulate op initial (cdr sequence)))))\n(accumulate + 0 (list 1 2 3 4 5))\n; expect 15\n\n(accumulate * 1 (list 1 2 3 4 5))\n; expect 120\n\n(accumulate cons nil (list 1 2 3 4 5))\n; expect (1 2 3 4 5)\n\n(define (enumerate-interval low high)\n  (if (> low high)\n      nil\n      (cons low (enumerate-interval (+ low 1) high))))\n(enumerate-interval 2 7)\n; expect (2 3 4 5 6 7)\n\n(define (enumerate-tree tree)\n  (cond ((null? tree) nil)\n        ((not (pair? tree)) (list tree))\n        (else (append (enumerate-tree (car tree))\n                      (enumerate-tree (cdr tree))))))\n(enumerate-tree (list 1 (list 2 (list 3 4)) 5))\n; expect (1 2 3 4 5)\n\n;;; 2.3.1\n\n(define a 1)\n\n(define b 2)\n\n(list a b)\n; expect (1 2)\n\n(list 'a 'b)\n; expect (a b)\n\n(list 'a b)\n; expect (a 2)\n\n(car '(a b c))\n; expect a\n\n(cdr '(a b c))\n; expect (b c)\n\n(define (memq item x)\n  (cond ((null? x) false)\n        ((eq? item (car x)) x)\n        (else (memq item (cdr x)))))\n(memq 'apple '(pear banana prune))\n; expect False\n\n(memq 'apple '(x (apple sauce) y apple pear))\n; expect (apple pear)\n\n(define (equal? x y)\n  (cond ((pair? x) (and (pair? y)\n                        (equal? (car x) (car y))\n                        (equal? (cdr x) (cdr y))))\n        ((null? x) (null? y))\n        (else (eq? x y))))\n(equal? '(1 2 (three)) '(1 2 (three)))\n; expect True\n\n(equal? '(1 2 (three)) '(1 2 three))\n; expect False\n\n(equal? '(1 2 three) '(1 2 (three)))\n; expect False\n\n;;; Peter Norvig tests (http://norvig.com/lispy2.html)\n\n(define double (lambda (x) (* 2 x)))\n(double 5)\n; expect 10\n\n(define compose (lambda (f g) (lambda (x) (f (g x)))))\n((compose list double) 5)\n; expect (10)\n\n(define apply-twice (lambda (f) (compose f f)))\n((apply-twice double) 5)\n; expect 20\n\n((apply-twice (apply-twice double)) 5)\n; expect 80\n\n(define fact (lambda (n) (if (<= n 1) 1 (* n (fact (- n 1))))))\n(fact 3)\n; expect 6\n\n(fact 50)\n; expect 30414093201713378043612608166064768844377641568960512000000000000\n\n(define (combine f)\n  (lambda (x y)\n    (if (null? x) nil\n      (f (list (car x) (car y))\n         ((combine f) (cdr x) (cdr y))))))\n(define zip (combine cons))\n(zip (list 1 2 3 4) (list 5 6 7 8))\n; expect ((1 5) (2 6) (3 7) (4 8))\n\n(define riff-shuffle (lambda (deck) (begin\n    (define take (lambda (n seq) (if (<= n 0) (quote ()) (cons (car seq) (take (- n 1) (cdr seq))))))\n    (define drop (lambda (n seq) (if (<= n 0) seq (drop (- n 1) (cdr seq)))))\n    (define mid (lambda (seq) (/ (length seq) 2)))\n    ((combine append) (take (mid deck) deck) (drop (mid deck) deck)))))\n(riff-shuffle (list 1 2 3 4 5 6 7 8))\n; expect (1 5 2 6 3 7 4 8)\n\n((apply-twice riff-shuffle) (list 1 2 3 4 5 6 7 8))\n; expect (1 3 5 7 2 4 6 8)\n\n(riff-shuffle (riff-shuffle (riff-shuffle (list 1 2 3 4 5 6 7 8))))\n; expect (1 2 3 4 5 6 7 8)\n\n;;; Additional tests\n\n(apply square '(2))\n; expect 4\n\n(apply + '(1 2 3 4))\n; expect 10\n\n(apply (if false + append) '((1 2) (3 4)))\n; expect (1 2 3 4)\n\n(if 0 1 2)\n; expect 1\n\n(if '() 1 2)\n; expect 1\n\n(or false true)\n; expect True\n\n(or)\n; expect False\n\n(and)\n; expect True\n\n(or 1 2 3)\n; expect 1\n\n(and 1 2 3)\n; expect 3\n\n(and False (/ 1 0))\n; expect False\n\n(and True (/ 1 0))\n; expect Error\n\n(or 3 (/ 1 0))\n; expect 3\n\n(or False (/ 1 0))\n; expect Error\n\n(or (quote hello) (quote world))\n; expect hello\n\n(if nil 1 2)\n; expect 1\n\n(if 0 1 2)\n; expect 1\n\n(if (or false False #f) 1 2)\n; expect 2\n\n(define (loop) (loop))\n(cond (false (loop))\n      (12))\n; expect 12\n\n((lambda (x) (display x) (newline) x) 2)\n; expect 2 ; 2\n\n(define g (mu () x))\n(define (high f x)\n  (f))\n\n(high g 2)\n; expect 2\n\n(define (print-and-square x)\n  (print x)\n  (square x))\n(print-and-square 12)\n; expect 12 ; 144\n\n(/ 1 0)\n; expect Error\n\n(define addx (mu (x) (+ x y)))\n(define add2xy (lambda (x y) (addx (+ x x))))\n(add2xy 3 7)\n; expect 13\n\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n;;; Scheme Implementations ;;;\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n;; len outputs the length of list s\n(define (len s)\n  (if (eq? s '())\n    0\n    (+ 1 (len (cdr s)))))\n(len '(1 2 3 4))\n; expect 4\n\n\n;;;;;;;;;;;;;;;;;;;;\n;;; Extra credit ;;;\n;;;;;;;;;;;;;;;;;;;;\n\n; Tail call optimization tests\n\n(define (sum n total)\n  (if (zero? n) total\n    (sum (- n 1) (+ n total))))\n(sum 1001 0)\n; expect 501501\n\n(define (sum n total)\n  (cond ((zero? n) total)\n        (else (sum (- n 1) (+ n total)))))\n(sum 1001 0)\n; expect 501501\n\n(define (sum n total)\n  (begin 2 3\n    (if (zero? n) total\n      (and 2 3\n        (or false\n          (begin 2 3\n            (let ((m n))\n              (sum (- m 1) (+ m total)))))))))\n(sum 1001 0)\n; expect 501501\n"
        },
        "grading": {
            "Extra Credit": {
                "failed": 0,
                "locked": 0,
                "passed": 5
            },
            "Question 1": {
                "failed": 0,
                "locked": 0,
                "passed": 3
            },
            "Question 10": {
                "failed": 0,
                "locked": 0,
                "passed": 5
            },
            "Question 11": {
                "failed": 0,
                "locked": 0,
                "passed": 3
            },
            "Question 12": {
                "failed": 0,
                "locked": 0,
                "passed": 4
            },
            "Question 13": {
                "failed": 0,
                "locked": 0,
                "passed": 5
            },
            "Question 14": {
                "failed": 0,
                "locked": 0,
                "passed": 8
            },
            "Question 15": {
                "failed": 0,
                "locked": 0,
                "passed": 5
            },
            "Question 16": {
                "failed": 0,
                "locked": 0,
                "passed": 5
            },
            "Question 17": {
                "failed": 0,
                "locked": 0,
                "passed": 2
            },
            "Question 18": {
                "failed": 0,
                "locked": 0,
                "passed": 1
            },
            "Question 19": {
                "failed": 0,
                "locked": 0,
                "passed": 1
            },
            "Question 2": {
                "failed": 0,
                "locked": 0,
                "passed": 6
            },
            "Question 20": {
                "failed": 0,
                "locked": 0,
                "passed": 4
            },
            "Question 3": {
                "failed": 0,
                "locked": 0,
                "passed": 4
            },
            "Question 4": {
                "failed": 0,
                "locked": 0,
                "passed": 5
            },
            "Question 5": {
                "failed": 0,
                "locked": 0,
                "passed": 5
            },
            "Question 6": {
                "failed": 0,
                "locked": 0,
                "passed": 2
            },
            "Question 7": {
                "failed": 0,
                "locked": 0,
                "passed": 6
            },
            "Question 8": {
                "failed": 0,
                "locked": 0,
                "passed": 4
            },
            "Question 9": {
                "failed": 0,
                "locked": 0,
                "passed": 5
            },
            "Understanding scheme.py": {
                "failed": 0,
                "locked": 0,
                "passed": 3
            },
            "tests.scm": {
                "failed": 0,
                "locked": 0,
                "passed": 204
            }
        }
    },
    "server_time": "2015-11-19 23:49:05.029080",
    "submitter": {
        "created": "2015-08-26 00:06:29.273670",
        "email": [
            "bowenwang@berkeley.edu"
        ],
        "id": 6148998238830592,
        "is_admin": false
    },
    "tags": []
}